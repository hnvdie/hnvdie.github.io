<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pwn on </title>
    <link>/tags/pwn/</link>
    <description>Recent content in Pwn on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 20 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/pwn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bypassing Stack Canaries (Leak &#43; Write) - Pwn03.1</title>
      <link>/posts/bypass-stack-canary/</link>
      <pubDate>Wed, 20 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/posts/bypass-stack-canary/</guid>
      <description>&lt;h2 id=&#34;1-basic-file-checks&#34;&gt;1. Basic File Checks&lt;/h2&gt;&#xA;&lt;p&gt;Pertama, kita perlu memeriksa karakteristik file biner yang akan kita analisis:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Compile program dengan stack canary enabled&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gcc -m32 -fstack-protector-all bof4.c -o bof4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Check file properties&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file bof4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;checksec bof4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Output yang diharapkan:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bof4: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=..., for GNU/Linux 3.2.0, not stripped&#xA;&#xA;[*] &amp;#39;/home/user/bof4&amp;#39;&#xA;    Arch:     i386-32-little&#xA;    RELRO:    Partial RELRO&#xA;    Stack:    Canary found&#xA;    NX:       NX enabled&#xA;    PIE:      No PIE (0x8048000)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dari output di atas, kita bisa melihat:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bypass Stack Canary - Pwn03</title>
      <link>/posts/stack-canary-bf/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/posts/stack-canary-bf/</guid>
      <description>&lt;h3 id=&#34;apa-itu-stack-canary&#34;&gt;Apa itu Stack Canary?&lt;/h3&gt;&#xA;&lt;p&gt;Stack canary adalah mekanisme keamanan yang ditempatkan di stack untuk mendeteksi buffer overflow. Namanya berasal dari analogi &amp;ldquo;canary in a coal mine&amp;rdquo; - jika canary mati, ada bahaya.&lt;/p&gt;&#xA;&lt;h3 id=&#34;cara-kerja&#34;&gt;Cara Kerja:&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Setup&lt;/strong&gt;: Saat fungsi dipanggil, nilai random (canary) ditempatkan di stack antara buffer dan return address&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Verification&lt;/strong&gt;: Sebelum fungsi kembali, nilai canary diperiksa&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Detection&lt;/strong&gt;: Jika nilai berubah, program terminate dengan segfault&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;layout-stack-dengan-canary&#34;&gt;Layout Stack dengan Canary:&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;High Addresses&#xA;+-----------------+&#xA;| Return Address  |&#xA;+-----------------+&#xA;| Saved EBP       |&#xA;+-----------------+&#xA;| Stack Canary    | ← Canary ditempatkan di sini&#xA;+-----------------+&#xA;| Local Variables |&#xA;| (termasuk buffer)|&#xA;+-----------------+&#xA;Low Addresses&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-tools-dan-analisis&#34;&gt;2. Tools dan Analisis&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tools-yang-digunakan&#34;&gt;Tools yang Digunakan:&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;GDB dengan Pwndbg&lt;/strong&gt;: Debugger dengan enhancement untuk exploit development&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pwntools&lt;/strong&gt;: Python library untuk CTF exploits&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Checksec&lt;/strong&gt;: Untuk melihat proteksi binary&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Objdump&lt;/strong&gt;: Untuk melihat assembly code&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;contoh-output-pwndbg&#34;&gt;Contoh Output Pwndbg:&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gdb ./vulnerable_program&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pwndbg&amp;gt; checksec&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[*] &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;/home/user/vulnerable_program&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Arch:     i386-32-little&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RELRO:    Partial RELRO&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Stack:    Canary found&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NX:       NX enabled&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PIE:      No PIE (0x8048000)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pwndbg&amp;gt; disassemble vulnerable_function&#xA;Dump of assembler code for function vulnerable_function:&#xA;   0x080484db &amp;lt;+0&amp;gt;:     push   ebp&#xA;   0x080484dc &amp;lt;+1&amp;gt;:     mov    ebp,esp&#xA;   0x080484de &amp;lt;+3&amp;gt;:     sub    esp,0x28&#xA;   0x080484e1 &amp;lt;+6&amp;gt;:     mov    eax,gs:0x14&#xA;   0x080484e7 &amp;lt;+12&amp;gt;:    mov    DWORD PTR [ebp-0xc],eax  ; Canary disimpan di [ebp-0xc]&#xA;   0x080484ea &amp;lt;+15&amp;gt;:    xor    eax,eax&#xA;   0x080484ec &amp;lt;+17&amp;gt;:    sub    esp,0x4&#xA;   0x080484ef &amp;lt;+20&amp;gt;:    push   0x100&#xA;   0x080484f4 &amp;lt;+25&amp;gt;:    lea    eax,[ebp-0x2c]&#xA;   0x080484f7 &amp;lt;+28&amp;gt;:    push   eax&#xA;   0x080484f8 &amp;lt;+29&amp;gt;:    push   0x0&#xA;   0x080484fa &amp;lt;+31&amp;gt;:    call   0x80483a0 &amp;lt;read@plt&amp;gt;&#xA;   0x080484ff &amp;lt;+36&amp;gt;:    add    esp,0x10&#xA;   0x08048502 &amp;lt;+39&amp;gt;:    mov    eax,DWORD PTR [ebp-0xc]&#xA;   0x08048505 &amp;lt;+42&amp;gt;:    xor    eax,gs:0x14&#xA;   0x0804850c &amp;lt;+49&amp;gt;:    je     0x8048513 &amp;lt;vulnerable_function+56&amp;gt;&#xA;   0x0804850e &amp;lt;+51&amp;gt;:    call   0x80483c0 &amp;lt;__stack_chk_fail@plt&amp;gt;&#xA;   0x08048513 &amp;lt;+56&amp;gt;:    leave  &#xA;   0x08048514 &amp;lt;+57&amp;gt;:    ret    &#xA;End of assembler dump.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Yang perlu dipahami dari output:&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Memahami Stack Frame dan Memory Layout - pwn02</title>
      <link>/posts/memory-layout/</link>
      <pubDate>Wed, 13 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/posts/memory-layout/</guid>
      <description>&lt;p&gt;Dalam binary exploitation, memahami struktur stack frame dan memory layout adalah fundamental. Artikel ini akan menjelaskan secara step-by-step bagaimana stack bekerja, cara membaca memory dengan &lt;code&gt;pwndbg&lt;/code&gt;, dan visualisasi yang mudah dipahami. Kita mulai dari layout memory, penggunaan &lt;code&gt;pwndbg&lt;/code&gt;, parsing stack, hingga cara membacanya untuk keperluan binary exploitation.&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-layout-memory-dan-stack-frame&#34;&gt;&lt;strong&gt;1. Layout Memory dan Stack Frame&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;/images/memory-layout0.webp&#34; alt=&#34;Main Frame&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Stack adalah struktur data LIFO (Last In, First Out) yang digunakan untuk menyimpan data sementara, seperti variabel lokal, return address, dan saved base pointer. Berikut tahapan pembentukan stack frame:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Belajar Bahasa Assembly (x86/x64, Termasuk 32bit)</title>
      <link>/posts/assembly-language/</link>
      <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/posts/assembly-language/</guid>
      <description>&lt;h3 id=&#34;1-apa-itu-bahasa-assembly&#34;&gt;1. Apa itu Bahasa Assembly?&lt;/h3&gt;&#xA;&lt;p&gt;Bahasa Assembly adalah bahasa pemrograman tingkat rendah yang berhubungan langsung dengan instruksi CPU.&lt;/p&gt;&#xA;&lt;p&gt;Bahasa ini tidak abstrak seperti Python atau C; setiap instruksi berhubungan langsung dengan operasi hardware.&lt;/p&gt;&#xA;&lt;p&gt;Setiap baris kode Assembly diterjemahkan oleh assembler menjadi opcode biner yang dipahami CPU.&lt;/p&gt;&#xA;&lt;p&gt;Kenapa belajar Assembly?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Memahami cara kerja komputer di level paling dasar.&lt;/li&gt;&#xA;&lt;li&gt;Berguna untuk reverse engineering, optimisasi performa, dan pemrograman embedded.&lt;/li&gt;&#xA;&lt;li&gt;Membantu memahami sistem operasi, compiler, dan arsitektur CPU.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-arsitektur-x86-vs-x64&#34;&gt;2. Arsitektur x86 vs x64&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;x86&lt;/strong&gt; → Arsitektur 32-bit (register umum: EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;x64&lt;/strong&gt; → Arsitektur 64-bit (register umum lebih banyak: RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, + R8-R15).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;32-bit vs 64-bit&lt;/strong&gt; → Perbedaan utamanya:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ukuran register (32-bit vs 64-bit)&lt;/li&gt;&#xA;&lt;li&gt;Panjang pointer (alamat memori)&lt;/li&gt;&#xA;&lt;li&gt;Instruksi tambahan di x64&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-memahami-register-cpu&#34;&gt;3. Memahami Register CPU&lt;/h3&gt;&#xA;&lt;p&gt;Register adalah ruang penyimpanan kecil di dalam CPU untuk operasi cepat.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tentang Binary Exploitation dan Buffer Overflow - pwn01</title>
      <link>/posts/buffer-overflow/</link>
      <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
      <guid>/posts/buffer-overflow/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://i.ibb.co.com/hRyZnWQm/images-3.jpg&#34; alt=&#34;PWN THUMB&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Binary exploitation merupakan salah satu keahlian paling krusial dalam dunia penetration testing dan keamanan siber. Teknik ini memungkinkan kita menemukan dan memanfaatkan kerentanan tingkat lanjut dalam program dan sistem operasi, yang seringkali menjadi pintu masuk untuk mendapatkan kendali penuh atas sistem target (remote code execution) atau meningkatkan hak akses secara lokal (privilege escalation).&lt;/p&gt;&#xA;&lt;p&gt;Selama bertahun-tahun, berbagai proteksi telah dikembangkan untuk memitigasi kerentanan memori, mulai dari tingkat kernel sistem operasi hingga teknik kompilasi binary. Namun, selalu ada celah untuk mengeksploitasi kesalahan-kesalahan kecil dalam penanganan memori pada binary.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Apa itu CPU, memory, disk, register dalam reverse engineering (RE)</title>
      <link>/posts/reverse-engineering-01/</link>
      <pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate>
      <guid>/posts/reverse-engineering-01/</guid>
      <description>&lt;p&gt;Penjelasan sederhana tentang komponen komputer yang penting untuk dipahami dalam &lt;strong&gt;reverse engineering&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-cpu-central-processing-unit&#34;&gt;1. &lt;strong&gt;CPU (Central Processing Unit)&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Apa itu?&lt;/strong&gt; &amp;ldquo;Otak&amp;rdquo; komputer yang menjalankan instruksi program.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Fungsi dalam RE&lt;/strong&gt;: Ketika melakukan reverse engineering, Anda menganalisis bagaimana CPU memproses instruksi dari program (misalnya, bagaimana ia menghitung, membandingkan data, atau melompat ke bagian kode tertentu).&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Contoh&lt;/strong&gt;: Saat debugging, Anda melihat instruksi assembly yang dijalankan CPU.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;cpu-itu-seperti-koki-di-dapur&#34;&gt;&lt;strong&gt;CPU itu seperti Koki di Dapur&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;Bayangkan:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt; = Koki yang melakukan semua perhitungan dan perintah.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt; = Resep masakan yang harus diikuti koki.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Ketika kamu menjalankan program (misalnya &lt;code&gt;ls&lt;/code&gt; di terminal), CPU membaca instruksinya langkah demi langkah dan menjalankannya.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
